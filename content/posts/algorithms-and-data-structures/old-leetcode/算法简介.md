---
title: "算法简介"
date: 2022-09-04T18:56:44+08:00
topics: "algorithms-and-data-structures"
draft: true
---

# 算法的分类

算法可基本分为三类：

1. **决策问题**
   即`yes-no`问题，是否给出的解决方案或结果是最好

2. **优化问题**
   寻找最优的结果或者最优的方案

3. **数值计算问题**
   比如计算一些方程组的解

依据算法的解法难度进行分类：

* **P问题**
  具有多项式时间解法的问题

* **NP问题**
  全称为`Non-deterministic Polynomial`即非确定性的多项式可判定问题，我们并不知道NP问题是否多项式时间可解，但我们可以在多项式时间内判断由**非确定性算法**给出的答案是否正确。
  
  > 非确定性算法，更类似于猜测
  > 千禧年难题中的其中一个就是`P问题是否等于NP问题`，即对于NP问题是否存在多项式时间可解的算法

* **NPC问题**
  全称为**NP完全问题**，这其实是指NP问题中的一类特殊问题，其和NP问题集中的其他问题相关联（或者说其他问题可以转换为该问题），只要该NPC问题能被证明具有多项式时间的解法，其相关的算法也就具有了多项式时间解法。

# 算法分析（时间/空间）

> 这里只讨论时间，空间类似

算法的时间复杂度的分析的一个朴素想法，就是直接测量算法在具体机器上运行的具体时间。但各个算法的具体实现方法，运行算法的计算机平台的不同会导致同样的算法执行的现实时间不同，并且不便于算法之间的比较。

所以我们需要一种更加抽象、更加本质的方法来量化算法的时间复杂度。

首先，我们只考虑算法运行在一台抽象的计算机模型上，把一条指令（或者语句）执行的时间定义为一个时间单元，故考虑算法的运行时间，只需要考虑执行了多少条指令或语句即可，而不去考虑一条指令需要多少具体执行时间。

此时我们已经可以具体的计算出不同算法的执行时间了，比如$100n, n^2+10n+5, 2^n$，此时我们已经可以定量的比较算法的好坏了。

但此时由于常系数的存在，导致我们的比较，仍需要比较具体分析，这当然没错，我们可以知晓在哪个具体的输入规模下哪个算法更好。但实际的算法中一般不会有太大的常系数，并且我们一般想要知道在输入规模足够大的情况下哪个算法更好。

所以算法的时间复杂度采用了渐进比较的办法，即采用了同阶无穷大来代表每个算法在输入足够大时执行时间的数量级。

具体的渐进时间复杂度的定义如下：

1. 对于所有的实际时间复杂度$f(n)$，若$\lim_{n\rightarrow+\infty}\frac{f(n)}{g(n)}=C or 0$，则$f(n)\in O(g(n))$
   通俗一点就是若$f(n)$为$g(n)$的低阶或者同阶无穷大，则归为集合$O(g(n))$

2. 对于所有的实际时间复杂度$f(n)$，若$\lim_{n\rightarrow+\infty}\frac{f(n)}{g(n)}=+\infty or C$，则$f(n)\in \Omega(g(n))$
    即$f(n)$为$g(n)$的高阶或同阶无穷大，则归为集合$\Omega(g(n))$

3. 对于所有的实际时间复杂度$f(n)$，若$\lim_{n\rightarrow+\infty}\frac{f(n)}{g(n)}=C$，则$f(n)\in \Theta(g(n))$
    即f(n)为$g(n)$的同阶无穷大，则归为集合$\Theta(g(n))$

> 对于小写的集合$o$和$\omega$，则是对应的大写集合去除同阶的函数构成的
