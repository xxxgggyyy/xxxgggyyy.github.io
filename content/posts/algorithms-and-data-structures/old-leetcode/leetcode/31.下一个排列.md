---
title: "31.下一个排列"
date: 2022-10-04T11:38:07+08:00
topics: "algorithms-and-data-structures"
draft: true
---

## 题目
整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。

例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。
整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。
类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。
而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。
给你一个整数数组 nums ，找出 nums 的下一个排列。

必须 原地 修改，只允许使用额外常数空间。

## 题解

首先要明确这里的字典序的大小，其实和十进制的大小类似，完全升序的最小（相当于高位是最小值），完全降序的最大（高位的最大）。

若要找当前序列的下一个更大的排列，从当前序列的末尾向前找第一个非升序（从后的升序，从后往前逐渐增大）的，如果每找到，则是完全降序的，需要重排，如果找到了，前面不变，只需重排后面的即可。(具体见代码，自然语言叙述太麻烦)

另一个技巧是，升序到降序转换只需$O(n)$

```cpp
/*我tm开窍了？？？，竟然和题解想得一样*/

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        // 从后往前找非深序
        int s = -1;
        for(int i=nums.size()-1;i>0;i--){
            if(nums[i-1] < nums[i]){
                s = i-1;
                break;
            }
        }

        // 完全降序则需要重排
        if(s==-1){
            up_order(nums, 0);
            return;
        }

        // 重排s之后
        up_order(nums, s+1);

        // 从后往前找大于s但最接近s的
        int nearsest=nums.size()-2;
        while(nearsest > s && nums[nearsest] > nums[s]){nearsest--;}

        // 交换
        swap(nums[s], nums[nearsest+1]);
    }

    // 降序转升序
    void up_order(vector<int>& nums, int s){
        int i=s, j=nums.size() - 1;
        for(;i<j;i++, j--){
            swap(nums[i], nums[j]);
        }
    }
};
```
