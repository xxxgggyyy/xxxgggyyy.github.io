---
title: "数据库相关杂项"
date: 2023-11-10T14:30:55+08:00
topics: "database"
draft: true
---

## 事务的ACID

A即Atomic原子性，这里的原子性就是指事务里的操作要么全成功要么全失败。

> 注意和并发编程原子操作的比较，那个原子操作全成功和全失败的语义不强，主要是要互斥独占的执行。
> 但事务的互斥执行的概念单独放在了隔离性中

I即Isolation隔离性，表示每个事务之间不会互相影响，就像是在独立执行一样

D即Durability持久性，表示修改了的操作一定会被持久化（落盘）

C即Consistency一致性，表述事务的执行前后数据库状态的一致性（当然就算失败了回滚后也要一致）。

这里的一致是相对于，数据库本身持有的约束而言的，用户在DBMS中指定了的约束，那么事务一定不能破坏。

但是如果某些约束由应用层来维护的，那就和事务没有关系，这个一致性本身是应用层来保证的。

## 三种Join方式

### Nested loops

就是嵌套循环，将小的表作为外表（驱动表）遍历，然后在另一张表（内表）上查询是否存在相应的join列。

该算法通常适用于驱动表较小，且外表存在索引的情况。

### Hash Join

使用较小的表根据其Join Key构建Hash Map，然后遍历大的另外一张表，依次到该Hash Map中查询是否存在对应的行，及其行号。

理想情况下时间复杂度就是遍历两个表的时间。

那为何一定要使用较小的表来构建hash map? 理由如下：

1. 用两张表构建的hash map如果内存都能容纳，那么总的时间复杂度是类似的。但是会使用更多的内存。
2. 如果构造的Hash map不能被内存容纳的话，只能分区，将会导致另一张表被多次遍历。所以尽可能选小的表，最好是内存能容纳。

### Merge Join

分别对两个表根据Join Key排序，然后两两比较，可直接得出结果。

如：

0  1
1  1
5  3
6  5

也是个类似嵌套循环，遍历左边，的同时嵌套遍历右边。

访问到0时，发现0 < 1，则直接下一个。

访问1，继续右边，发现两个1，3>1结束内循环，然后内循环下次从3开始比较

访问5, 5 >3，跳过，5 == 5加入结果，右边没有了结束

在排完序后利用两边的有序性，时间复杂度相当于也只需要遍历两张表即可

当然由于排序太耗时了，除非join key本身就是排序的，不然使用hash join总是更快

