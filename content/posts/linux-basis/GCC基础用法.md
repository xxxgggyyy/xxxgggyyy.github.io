---
title: "GCC基础用法"
date: 2022-06-19T15:16:48+08:00
topics: "linux-basis"
draft: true
---

# GCC简介

> GCC--GNU Compiler Collection，GNU编译套件

GCC原名为GNU C编译器，但很快被扩展为支持C++、Fortran、Java、Objective-C等语言

# gcc/g++基础用法

> C语言一般就用gcc，C++用g++
```sh
gcc [-c|-S|-E] [-std=standard]
           [-g] [-pg] [-Olevel]
           [-Wwarn...] [-Wpedantic]
           [-Idir...] [-Ldir...]
           [-Dmacro[=defn]...] [-Umacro]
           [-foption...] [-mmachine-option...]
           [-o outfile] [@file] infile...
```
> 这里只列出了最常用的选项，详细选项请用man查看。
> g++的大部分参数和gcc的用法相同
> 其实gcc也可以通过后缀名编译c++文件，但其不会添加c++的库文件。g++会自动调用gcc并指定相应的链接库文件。

## || gcc参数介绍
gcc的执行过程有四个阶段：预处理、编译、汇编、链接。
`overall`参数允许你将gcc停留在任何阶段，如`-c`表示完成前三个阶段但不链接。
其他的一些参数传递给各个阶段的处理过程。
gcc中多字符参数具有单独的含义，即`-dv`和`-d -v`意义是不同的。
大多数情况下参数的的顺序是没有影响的，但对于多个同类的参数是有影响的。比如多次指定了`-L`，那么搜索库的顺序将按照指定的顺序。
长名参数一般以`-f`、`-W`开头如`-Wformat`等，长命参数一般有简写形式。
除非特殊说明大部分选项后接的参数都是数字或者字符串，但对于`byte-size`类型的参数可以在后接单位，`KB`、`KiB`、`GB`等。

## || 文件后缀对gcc的影响
后缀|影响
:-:|:--
.c|需要预处理的C源文件
.i|不应该执行预处理的C源文件
.ii|不应该执行预处理的C++源文件
.cc/.cp/.cxx/.cpp/.CPP/.c++/.C|需要预处理的C++源文件
其他语言类型|非c/c++相关文件

也可以通过`-x lang`指定语言，而不是通过后缀名让gcc自己决定。

## || gcc部分参数详解

### 控制gcc执行阶段
通过文件命后缀或者`-x`指定，gcc从哪个阶段开始执行，通过选项`-c`、`-S`、`-E`决定gcc在哪个阶段停止
* `-c`，简单的不执行链接。输出文件为`.o`
* `-S`，编译之后终止，即不进行汇编和链接。输出`.s`的汇编源文件
* `-E`，停在预处理阶段之后，在标准输出中输出预处理过后的文件

### C/C++标准/方言
* `-std=`，可以指定c89、c90、c11、c++11等
* `-ansi`，在C模式下相当于`-std=c90`，C++模式下相当于`-std=c++98`

### 警告信息

* `-w`，禁止所有的警告信息
* `-Werror`，将所有的警告转为错误信息
* `-fsyntax-only`，仅做语法检查，其他什么也不做

### 生成调式信息

* `-g`，生成本地格式的调试信息。GDB可使用该格式
* `-ggdb`，生成GDB使用的调试信息
* `-gstabs`，生成stab格式的调试信息
* `-glevel`，level表示调试信息的等级，0不包含调试信息，1包含足够的信息，3包含许多额外的信息。

### 程序优化参数
如果不指定优化，则gcc的目标是，尽量减少编译时间并按顺序编译方便调试。
而优化将会增加编译时间甚至失去可调试的能力，但能减小程序体积加快程序运行速度。

* `-O0`，默认参数，不做任何优化
* `-O1`，即`-O`，会减小程序的体积和加快执行速度，但不会做需要花大量编译时间的优化
* `-O2`，进一步优化
* `-O3`，进一步优化
> 具体`-O`参数打开的优化开关见文档

### 预处理的相关参数

* `-D name=def`，定义名为name的宏，相当于`#define`
* `-U name`，取消宏定义。包括`-D`定义的和文件自身定义的
* `-include file`，类似添加`#include "file"`到主文件的第一行，但是`file`的查找目录是预处理器的工作目录，而不是主文件所在位置
* `-pthread`，定义使用POSIX thread lib要求定义的宏。编译和链接阶段均需要使用
* `-M`，在stdout输出源文件的依赖头文件。（以make rule的形式）
* `-MM`，同`-M`但不显示系统头文件
* `-MT target`，指定`-MM`中生成的make rule中的target
* `-MQ target`，同`-MT`只是生出的目标名会做make转义，主要是`$`的转义即`$$`
* `-MF file`，指定`-M`生成输出到文件

### 链接器相关的选项
* `-lname`，指定链接库需要配合`-L`指定链接库所在目录使用。
  gcc会在缺省目录和`-L`目录下搜索`libname.a`和`libname.so`，如果两个都找到那么默认使用`.so`的动态链接库除非指定`--static`参数。
  注意`-l`和其他`.o`文件的顺序，比如`main.o`引用了`libname.a`的函数，则`libname.a`必须后指定，`gcc main.o -lname -L.`
  无论时静态链接库还是动态链接库，都可以像`.o`一样直接作为参数传递链接，也可以使用`-l`指定
  > 当然linker是根据`.so`和`.a`区分是静态链接还是动态链接的
  > 此时的动态链接库，是目标文件执行时自动加载的，但此时还未配置可执行文件的动态库搜索目录，所以会出现`.so`找不到的错误。可以使用`-Wl,rpath`在编译时指定，也可以修改`LD_LIBRARY_PATH`环境变量，也可编辑`/etc/ld.so.conf`文件。
  
* `-Wl,option`，将option表示的参数传递给链接器。
可使用`-Wl,rpath=libpath`添加动态链接库搜索路径到可执行文件。


### 指定搜索目录
* `-I`，指定头文件目录。当前目录和缺省目录（/usr/include和/usr/local/include）不用指定
* `-L`，指定链接器搜索目录。结合`-l`参数使用

### 其他参数
选项|功能
:-:|:--
`-o`|指定最终输出的文件名
`-v`|打印各个阶段执行的命令以及版本信息等
`--help={class}`|答应对应class的帮助信息。class可取值`optimizers`、`warnings`、`target`等
`@file`|从该文件中读取选项参数


# gdb基础用法

命令|描述
:-:|:--
`l [l-num]`| 显示10行代码内容，指定行号时以行号剧中显示上下10行
`r`|开始调试直到断点，再次执行`r`会重新开始调试
`where`|查看此时执行位置
`b ln`|在行号`ln`处打断点
`info b [b-num]`|显示全部断点
`d [b-num]`|删除全部断点或指定断点
`c`|执行到下一个断点位置
`until l-num`|执行到指定行号
`s`|逐语句执行
`n`|逐过程执行
`finish`|结束当前函数，即执行到跳出当前函数
`bt`|backtrace，即显示调用堆栈
`disable b-num`|关闭断点
`enable b-num`|打开断点
`p [&]var`|打印一次变量值或变量地址
`display var`|一直显示变量值
`info display`|显示`display`的变量信息
`undisplay var-num `|根据变量编号关闭`display`
`disassemble`|反汇编当前执行位置附近指令
`shell cmd`|执行shell指令
`q[uit]`|退出