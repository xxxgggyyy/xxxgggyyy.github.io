---
title: "第一章绪论"
date: 2022-06-19T15:16:48+08:00
topics: "linux-kernel"
draft: true
---

# GNU/Linux

GNU（GNU's Not Unix）项目是FSF（自由软件基金会）发起的，目的在于开发和商业UNIX不同的，完全自由的操作系统。
到1990年，GNU项目已完成了大部分UNIX系统的程序库和工具的开发，包括GCC、Emacs等等，唯一**未完成**的重要组件就是操作系统内核（HURD）。
到1992年，由于Linux内核的蓬勃发展，在将Linux内核与其他GNU软件集合后，完全自由的操作系统正式诞生。

> Linux是一个真正的UNIX内核，但其不包含全部的UNIX程序，故最初其并非一个完整的操作系统
> Linux内核需要大量的运行其他软件才能为用户提供一个有用的环境，故大多数用户喜欢经过商业包装的Linux发行版，以获得包含了UNIX应用层代码的完整操作系统。

# Linux与其他类Unix内核比较

所有商业版本的类UNIX系统都是SVR4或BSD4.4的变体，并趋于遵循相同的标准，如POSIX、CAE
> POSIX等标准仅规定了应用程序编程接口（API），未对内核的设计施加限制

为了定义通用的用户接口，类UNIX基本也采用相同的设计思想和特征。Linux2.6的目标就是遵循POSIX标准，同理Linux和其他类UNIX一样。
此外Linux包括了现代Unix的全部特点，如虚拟存储、虚拟文件系统、信号量等等

Linux内核的一些特征
> 这写特征下文**UNIX内核概述**中由较为详细的说明

* **单块结构的内核**
大多数商业Unix变体均为单块结构内核，但Mac Os X和GNU的HRUD采用微内核方法。
* **内核自动按需装载模块**
能被内核装载和卸载的部分代码称为模块（modules）。Linux能自动按需装载和卸载模块，在其他商用UNIX中只有SVR4.2和Solaris有类似特征，其他均为静态链接。
* **内核线程？？？**
一些UNIX内核被组织成一组内核线程。内核线程是一个能被独立调度的执行环境（contex）。
但Linux仅使用内核线程周期性的执行几个内核函数，而不作为基本的调度单位。
* **多线程程序支持？？？**
一个多线程程序，由许多轻量级进程组成（LWP），所有的商用Unix的LWP都基于内核线程。但Linux却把LWP作为基本的执行上下文。
* **抢占式内核**
抢占式编译的Linux内核，支持随意的交错执行处于特权模式的执行流
* **多处理器支持？？？**
Linux2.6支持不同存储模式的对称多处理（SMP）
* **文件系统**
Linux具体有多种标准文件系统。没有特殊需求可采用ext2，避免系统崩溃后冗长的文件系统检查可以采用ext3，如果不得不处理很多小文件可以采用ReiserFS系统。
* **STREAMES**
Linux并没有STREAMES I/O类似的子系统

# Linux的硬件依赖性

Linux试图在硬件无关源码和硬件相关源码之间保持清晰的界限。
`arch/`和`include/`目录中的不同子目录即对应Linux支持的各种硬件平台。

>`um`子目录表示用户态linux--允许开发者在用户态运行内核的虚拟平台
>其他子目录对应的平台介绍见书籍P12

# Linux版本

一直到2.5版本的内核，版本号由三位组成，前两位表示版本号，最后一位表示发布号。
第二位版本号，也用于区分开发版和稳定版，偶数为稳定版，奇数为开发版。
而稳定版的第三位发布号，则用于更新驱动，或者修复用户报告的错误。
但2.6版的开发中版本编号含义发生了变化，第二位版本号不再用于区分开发版和稳定版，而是类似现在的三段版本号的含义。
并且新增了第四位表示该版本的补丁版本。

# 操作系统的基本概念

一般意义上的操作系统其实分为内核和实用程序。
内核提供操作系统基础和必要功能，所以内核又被称为基本操作系统。
在此书中操作系统和内核等价，而不考虑OS的其他实用程序。

**两个角度看OS**

* OS作为资源（包括软硬件资源）的管理者
* OS作为服务的提供者（提供执行环境）

为了实现以上两个功能，OS必须禁止用户直接访问硬件资源。故CPU提供了用户态和内核态。处于用户态的程序只有通过系统调用（即通过内核）来访问特定的资源，而系统调用已处于OS的管控之下。

## || 多用户系统
即多个用户可以并发和独立的做自己的工作。

## || 用户和组
> 参见Linux基础用法
## || 进程
进程即程序执行的实例。
进程其实是为了更方便管理多道程序系统，而产生的自然而然的概念。

## || 内核体系结构

Linux采用的是宏内核的结构（方式）。

微内核只实现简单的进程管理、进程间通信、同步原语、调度程序等非常底层的必要功能，而将诸如文件系统、驱动程序等传统内核级代码，作为特殊的进程执行。

微内核更具有一定的理论优势，比如易于移植（内核很小）、模块化、系统级进程可调出提高RAM利用率（比如将一些不用的驱动程序单独调出，因为此时驱动是作为单独的进程实现的）等等。

但微内核一般比宏内核慢，因为不同系统层传递消息需要消耗。

Linux为了达到微内核理论上的优点而又不影响性能，采用了模块的概念（module），即可以将部分内核代码分出作为模块，在运行时动态加载或者卸载，但和微内核不同，这些模块不是单独进程，仍然作为代码载入，和普通静态链接的代码没有区别 

# UNIX文件系统概述

> 参见**Linux基础用法-UNIX文件系统**

## || 文件
## || 硬链接和软链接
**硬链接的限制**
1. 不能为目录创建硬链接。这将会在树状目录中引入环，有可能导致混乱。
2. 不能跨文件系统链接

为了解决这些文件，出现了软链接。

## || 文件类型
补充两种用于进程通信的特殊文件
* 管道文件
* 套接字文件

## || 文件描述符于索引节点
## || 访问权限与文件模式
除了熟知的三种用户ugo，三种访问权限rwx，还有三种附加的标记。
* suid(Set User ID)，当可执行文件设置该标志位后，该文件产生的进程拥有该文件的UID，而不是执行进程的UID
* sgid(Set Group ID)，同suid，只不过是对用户组来说。
* sticky，设置该标志位的可执行文件，当程序结束时依然保留在内存。（stick已过时）

> 这里的suid和sgid就是说，u和g分别具有一个s标记，见**Linux基础用法-sudo权限提升原理**
> 另外进程是有两个UID的，ruid和euid，s标记改变的是euid（即进程权限相关的有效ID），ruid还是表示进程创建者。

当进程创建文件时，文件拥有该进程的UID。
而该文件的组ID，或许是进程的组ID，也可能是父目录的组ID，这取决于父目录是否设置sgid

## || 文件操作的系统调用

### 打开文件
```c
fd = open(path, flag, mode)
```
`flag`文件打开方式（读、写、追加、读写等）
`mode`指定创建文件的访问权限
`open`会创建一个所谓的`open file object`，包含参数指定的`flag`、文件位置指针、允许该进程可调用的内核函数指针（有哪些取决于`flag`）
`fd`文件描述符标识该打开文件对象。
几个进程同时打开一个文件，UNIX文件系统分别分配打开文件对象以及单独的文件描述符，并且不再进程中提供任何同步功能。

> 为什么要打开文件？
> 1. 确定文件是否存在，读取文件基本信息（i节点）
> 2. 验证文件权限
> 3. 准备数据结构（offset字段，可用函数指针等）

### 访问打开的文件
普通UNIX文件可进行顺序和随机访问，但设备文件和命名管道文件只能顺序访问。
默认位顺序访问，使用`write`和`read`，总是从文件指针位置开始读取。
使用`lseek`设置文件指针，文件指针偏移位单位为字节。
```c
noffset = lseek(fd, offset, whence);
```
`whence`标识新文件指针通过`offset`的计算方式，可以是`offset+0`，也可以是`offset`加当前指针。

### 关闭文件
```c
res=close(fd)
```
进程关闭时也会关闭所有该进程打开的文件。

### 更名及删除文件
```c
res=rename(oldpath, newpath);
res=ulink(pathname);
```
更名不用打开文件，应为是修改目录而不是文件
删除使用`ulink`取消一个硬链接索引，只有当索引为0是才删除。

# UNIX内核概述

## || 进程/内核模式

进程大多数都在用户态下执行，它不能直接访问内核数据和程序，也不能直接执行I/O指令，只有需要系统提供的服务时才使用系统调用（来执行特权指令）。
> 进程在用户态的限制，是由CPU通过硬件特性提供的
> 对于系统调用而言，此时其在内核中的运行仍然是代表该进程的，**使用的仍然是该进程的可执行上下文。**

一般而言CPU都会提供两种以上的执行状态，比如80x86提供四种状态，但所有标准UNIX内核都只使用了其中的两种状态（分别用于用户态和内核态的实现）。

除用户进程外，UNIX还包含一些被称为内核线程的特权进程，它们有如下特点
* 以内核态运行在内核空间
* 不与用户交互，故不需要终端
* 由系统启动时创建，一直活跃到系统关闭

导致切换到内核态的方式（激活内核例程）：
1. 系统调用
2. 中断，外部的设备发起的中断，CPU内部产生的中断、异常
3. 内核线程（即内核特权进程）

<u>进程调用系统调用后，要定时中断到来重新执行内核的进程调度才能恢复执行？？？</u>
> 这里的意思就是通过内部中断调用系统调用后，该进程就已经被放入就绪队列，需要再次调度才会被重新执行

## || 进程实现

内核通过进程描述符标识进程（根据书中上下文，该进程描述符应为PCB）
进程描述符中内容：

* 通用寄存器
* PC（CS）、SP、SS等
* 浮点寄存器
* PSW
* 跟踪进程对RAM访问的内存管理寄存器

## || 可重入内核

所有UNIX内核都是可重入的，这里可重入表示多个进程可同时进入内核态运行。
对于内核例程函数而言，若其仅修改局部变量，那么其天然是可重入的。
而对于需要访问全局变量那么需要锁来控制，一次只有一个进程能进入。

### 内核可重入性对内核设计的影响

先定义一个概念**内核控制路径**，其为任何在内核中执行的指令序列，包括内核系统调用、中断和异常处理例程等
可重入性对内核控制路径的影响：
* 对于上面讨论的带锁可重入函数（假设其为系统调用），此时若不能获得锁，则当前进程的内核控制路径被中断，重新调度一个进程运行
* CPU应该能被硬件中断，即使此时CPU处于内核态。这样及时的响应硬件，可以提高效率。若内核在执行一个进程的内核控制路径，此时硬件中断发生，该控制路径立即被中断，转而执行硬件中断处理例程。有趣的时，**此时中断处理程序运行在同一个进程上下文中**，所花费CPU时间都算在该进程里。
* 支持抢占式调度的内核中，高优先级到来，会立即中断当前进程的内核控制路径。
* 当运行一个控制路径时，CPU检测到了一个异常（当前执行引发的，比如内存页不在RAM中），此时控制路径被挂起。而是去执行一个合适的例程处理这个异常（比如给进程分配新页，并从磁盘加载）。

## || 进程地址空间

在用户态下进程运行在私有地址空间中，包括私有栈、数据区、代码区等。若其在内核态运行（内核代表进程运行）使用**另外的私有栈**。

因为内核时可重入的，所以可以有多个内核控制路径轮流执行，每个控制路径都有自己的内核栈。

进程也可以共享部分地址空间，通常有两种方式
1. 由内核自主完成的共享。比如同一个程序被多次执行，其代码区，就可被几个进程共享。
2. 进程主动的共享地址空间，来实现进程中通信。比如共享内存技术、文件内存映射技术

## || 同步和临界区

可重入的内核，毫无疑问是需要同步机制（同步内核控制路劲），来保护共享的内核数据结构的。

> 详细的同步技术讨论可以参见本科操作系统教材
> 因为内核是可重入的，此处讨论的是内核路径的同步，而不是进程本身业务逻辑的同步。

### 非抢占内核

最简单和彻底的解决内核路径同步问题的方案，就是非抢占的内核。
这里的非抢占是指当进程在内核态运行时，不能被任意挂起，不能被其他进程代替。通俗一点就是只能有一个进程处于内核态中。
> 此时仍然能被外部中断或者异常中断，但中断处理程序的上下文仍然是进程的。
> 所以此时也只是对于中断处理例程不会访问和修改的内核数据，是安全的

但这种方案，对于多核CPU无疑效率是低下的。此时应该使用同步技术，划分临界区，只需保证临界区代码的独占内核数据结构即可，其他代码仍然可利用多核心并行执行

### 禁止中断

禁止中断，只对单核CPU有一定的作用。此时时钟中断、硬件中断等都被屏蔽，让进程临界区处于独占状态。

### 信号量

信号量可以广泛用在单核和多核CPU上。信号量操作（PV操作）的原子性，其实是由`XCHG`、`TSL`等CPU指令实现的，因为这些操作的时间都非常的短，这些指令保证其操作的原子性，即`XCHG`即交换内存值和寄存器值，它们是通过锁定总线实现的，所以对多核CPU也有效
> 详情参见操作系统教材

### 自旋锁
自旋锁其实就是我们说的忙等待锁，当无法获得锁的时候，不停的执行检测（自旋）。上面说的`XCHG`指令就是实现自选锁的一种方式。
自旋锁，其实对于短时间临界区非非常友好的，因为等待时间非常短，而如果去使用信号量一套挂起操作还没完，说不定已经被释放了。更不用说，对信号量的原子操作都是由自旋锁实现的。

### 避免死锁
当内核使用的信号量较多时，死锁就一定会成为突出问题。
包含Linux在内的几种操作系统，通过按规定顺序请求信号量来避免死锁。
> 破坏循环等待条件

## || 信号及进程间通信

### 信号

UNIX信号提供了一种把系统事件报告给进程的一种机制。
由两种系统事件：
* 异步事件，比如用户在终端按下终端键
* 同步错误或异常，如进程访问非法地址等

POSIX标准定义了大概20中信号，<u>其中两种时用户自定义的，可以当作用户态进程通信和同步原语？？？</u>
进程对于收到的信号由两种处理方式：
* 忽略
* 异步执行用户指定的过程

> SIGKILL和SIGSTOP不能直接由进程处理，也不能由进程忽略
> 所以`kill -9 pid`可以强制终止进程

若未指定处理方式，系统默认由如下几种处理方式
* 终止进程
* 核心转储（上下文和地址空间内容都写入文件），然后终止
* 忽略信号
* 挂起
* 若被挂起，则恢复

### 进程间通信

System V引入了在用户态使用的通信机制：用户态信号量、消息队列、共享内存
很多UNIX也采用了这些机制，这些机制称为System V IPC
> 这里的信号量和前面的内核信号量的原理相同，只是一个在内核使用，一个在内核态使用。
> POSIX还定义了一种基于SV IPC消息队列的接口更简单的消息队列

内核把这些机制作为IPC资源来实现。
> 具体的实现见后文。

## || 进程管理

`fork`和`_exit`系统调用分别创建和终止一个进程。
父进程调用`fork`拷贝一个完全相同的子进程，在其是写时复制的。
然后子进程在调用`exec`重新装入程序即可。
当子进程退出时，会向父进程发送信号SIGCHLD（默认处理程序为忽略）
> 父子进程都能够通过PCB中的指针找到对方。

### 僵死进程

僵死进程是UNIX为终止的进程引入的特殊状态。
因为父进程一般希望获取子进程的退出状态，所以即使子进程终止了也应该保留PCB以供父进程查阅。
父进程通过`wait4`系统调用查看所有子进程的执行状态，此时有僵死进程则返回僵死进程的信息并将其从PCB表中删除，若没有，则父进程等待，直到子进程结束。

但父进程直到其结束也无法保证一定会调用`wait4`（用户的行为无法控制），这样会导致僵尸进程占用的系统资源得不到释放。
UNIX提供的解决方案是，当一个进程终止时，会将其所有存在的子进程（还在执行的，僵死的）都修改指针，作为特殊进程`init`的子进程，然后由`init`进程周期性的执行`wait4`来消除僵死进程。
> 父进程除了显示的调用`wait4`，也可以通过定义`SIGCHLD`信号处理程序，在其中执行`wait4`来消除僵死进程

很多内核也实现了`waitpid`系统调用来单独的等待某个进程。

### 进程组和登录会话

UNIX引入了进程组的概念，进程PCB中有一个组ID表示其所在组。每个组中PID和组ID相同的即为该组领头程序。
新创建的进程默认加入父进程的进程组。
shell命令`ls|sort|more`就创建了一个进程组，每个进程组就像单独的实体一样。

UNIX也引入了登录会话的概念。一个登录会话包含在指定终端工作的所有进程。
进程组中的所有进程必须处在同一个登录会话中。
一个登录会话，可以有几个进程组。
通过shell命令`bg`和`fg`可以将一个进程组
后台进程访问终端时会收到`SIGTTIN`和`SIGTTOUT`信号。

## || 内存管理

### 虚拟内存
> 参见操作系统教材
### RAM的使用
RAM一般分为两部分，一部分用于内核映像（内核代码和静态数据结构），一部分交给虚拟内存系统处理。虚拟内存系统需要处理三种可能的请求：
* 满足内核对于缓冲区、描述符以及其他动态数据结构的请求
* 满足进程对一般内存和文件映射的请求
* 作为磁盘及其它缓冲设备的缓存

当物理内存不足时，还可以调用页框（物理页）会后算法。
> 具体回收哪些，没有明确的理论支持，一般依靠经验算法

### 内核内存分配器
内核内存分配器（KMA）是内核的一个子系统。
KMA试图满足所有的对内存的请求，一些请求来自内核的其他子系统，一些来自用户程序对于增加自身内存地址空间的请求。
将在第八章介绍，Linux的KMA在伙伴系统之上采用Slab分配算法。

### 进程虚拟地址空间处理

内核用一组内核区描述符描述进程的虚拟地址空间。通过`exec`执行新程序时，一般由以下内存区构成:
* 代码区
* 初始化数据区
* 未初始化数据区
* 初始栈
* 初始堆
* 共享库代码和数据

对于请求调页（即分配新页框），只有当进程引用虚拟内存地址出现异常时（MMU发出），才会执行。
而对于`malloc`和`brk`函数，内核仅仅是修改堆内存区大小。

对于写时复制，当创建新进程时，直接把父进程的页框赋给子进程即可，但将其设置为只读的。当父或子试图写入数据时就会产生异常，导致分配并初始化新页框。

### 高速缓存
RAM用作磁盘和其他设备的高速缓存。
由于磁盘的速度和RAM比实在太慢了，所以类似`cache`一样，为磁盘设置高速缓存。
即推迟任何的写磁盘时间，即使进程被撤销，其使用过的资源也仍然存在缓存中，期望其他进程也将会用到这些数据。
系统会周期性的调用`sync`系统调用，将`脏`缓存（即修改过的）写回磁盘以保持数据一致。

## || 设备驱动程序

每个设备文件都有专门的设备驱动程序，其实设备文件时设备驱动程序接口中用户可见的部分。

驱动程序通过特定的接口与内核相互作用，有以下有点。
* 封装特定设备代码为模块，需要时动态加载而不用重启系统，不用时动态卸载减小RAM中内核映像。
* 厂商可以通过接口快速的开发设备
* 内核以统一的方式对待所有的设备，通过接口访问
