---
title: "第二章内存寻址"
date: 2022-06-28T21:34:22+08:00
topics: "linux-kernel"
draft: true
---

> 关于内存管理的讨论一共有三章，还有第八章和第九章

# 内存地址

80x86中的三种地址：

* 逻辑地址，即在机器指令中给出的地址。对于80x86来说就是段地址和偏移地址
* 线性地址（即虚拟地址）
* 物理地址

**地址转换**

```mermaid
graph LR
A(逻辑地址) --> B[分段单元]
B-->C(线性地址)
C-->D[分页单元]
D-->E(物理地址)
```
其中分段单元与分页单元都是MMU中的。
> 80x86提供的应该是一种段页式虚拟内存机制

**内存仲裁器**
RAM上的操作只能串行的执行，如果有多个核心都要使用RAM则需要接入内存仲裁器，协调内存请求，而不是直接给到公共总线上。
> 即使在单处理器中，也需要仲裁器，仲裁DMA控制器和CPU
>
> 为何不直接使用总线仲裁？

# 硬件中的分段

从80286开始，intel的CPU就支持两种模式，一种实模式，一种保护保护模式。
实模式是为了兼容16位的8086芯片，其不支持多任务执行（没有硬件保护），不支持分页
保护模式，则提供了特权分级、分页支持、多任务保护等功能

> 现在电脑刚启动时仍然在使用实模式，因为已开始只有BIOS需要执行，无需多任务那些复杂功能

下文中描述的是**保护模式**下的寻址方式。

## || 段选择符和段寄存器

### 段选择符

一个逻辑地址分为两部分：段选择符和段内偏移量
> 在80x86保护模式中，原来的段地址（实模式中）变为了段选择符

段选择符为16位长的字段
15-3|2|10
:-:|:-:|:-:
索引号|TI|RPL
--|表指示器|请求者特权级

> 各位的含义见下文，需要介绍了GDT/LDT概念后才能说明
偏移量为32位长字段

### 段寄存器
含义和8086中段寄存器相同，增加了`fs`和`gs`两个通用段寄存器
* `cs`代码段寄存器。除此之外cs中还有一个两位字段表示表示**当前CPU特权级（CPL）**，值0表示最高特权，值3表示最低特权。Linux中只用到了0和3分别表示内核态和用户态
* `ss`栈段
* `ds`数据段
* 通用段寄存去`es`、`fs`、`gs`

## || 段描述符
> 描述符，一般是包含一组字段的，用来描述对象的特征，用来标识对象
> 比如进程描述符，其实是PCB

段描述符由8个字节组成，存放在全局描述符表（GDT）中，如果进程还需要创建附加的段可以放在自己的局部描述符表（LDT）中。
GDT在内存中的位置和大小由`gdtr`寄存器给出
当前在使用的LDT由`ldtr`寄存器给出

> 说通俗一点，GDT和LDT其实就是段表，段描述符就是段表项

### 段描述符格式
* 代码段描述符，可以放在GDT或LDT中，S字段置1（表示非系统段）
* 数据段描述符，可以放在GDT或LDT中，S字段置1。栈段是通过数据段实现的。
* 任务状态段描述符（TSSD），代表一个任务状态段（TSS）。TSS用来保存处理器寄存器的值（参见第三章），它只能出现在GDT中，其S字段置0为系统段。根据相应进程是否正在CPU上执行，其Type字段值分别为11和9。
* 局部描述符表描述符（LDTD），这个段代表了一个LDT段，只能出现在LDT中。Type=2，S=0

![段描述符格式](/images/摘录图片/描述符格式.jpg)

### 段描述符各字段含义

![段描述符格式](/images/摘录图片/描述符字段含义.jpg)

## || 快速访问段描述符

为了加快从逻辑地址（段+偏移）到虚拟地址的转换，CPU为8字节的段描述符提供了不可编程的缓存寄存器。当段选择符被装入到段寄存器时，对应的段描述符被自动从GDT/LDT中装载到该缓存寄存器。
>每个段寄存器应该都有一个对应的缓存寄存器

**段选择符各字段含义**
字段名|含义
:-:|:--
index|指定对应段描述符在GDT/LDT中的位置索引（从0开始索引）。实际的段描述符地址为：gdtr + index\*8。其中gdtr存储32位的gdt首地址，8表示段描述符为8字节
TI|表指示器，TI=0指示段描述符在gdt中，1指示在LDT中
RPL|请求者特权级，当段选择符装入CS时，指示处CPU当前的特权级别，还可以用于访问数据段时有选择的削弱特权级

GDT中第一项，总是设为0，这会导致空的段选择符的逻辑地址被认为无效，引起一个处理器异常。
GDT中最多只能有8191个段描述符，即2^13-1

## || 分段单元（逻辑地址转线性地址的过程）

1. 根据TI决定是哪个描述符表，确定使用`gdtr`还是`ldtr`（这两个寄存器存储了描述符表的线性基地址）
2. `index*8`加上`gdtr`或者`ldtr`，获取描述符地址
3. 将描述符中Base和逻辑地址中的offset相加，即可得线性地址

当然由于采用了描述符缓存寄存器，只有在新装入选择符时需要进行第1、2部，其他时候直接使用缓存的描述符的Base直接和offset相加即可得

# Linux中的分段

> 80x86提供了强大的分段支持，但Linux被设计为分页为主体，方便移植到对分段有限支持的平台。故Linux以非常受限的方式使用80x86提供的分段功能，也就是走个流程而已只是在80x86下必须

> 若是第一次阅读，建议先阅读
> * Linux分页-||进程分页
> * Linux分页-||内核分页
>
> 要知晓进程并非所有线性地址空间均可用，而是分为了两部分，前3GB的地址进程可自由寻址，高1GB用来存放内核，对于分页而言，自然页表也分为了两部分，其中前3GB对应的页表自然是每个进程所特有，最后1GB对应的页表其实是所有进程共享的。

Linux只有在80x86平台下才需要使用分段。（这是由于CPU一定会先通过分段单元）

## || Linux GDT

Linux GDT的大小是固定，其他的描述符项且不谈，这里主要介绍GDT中的四个描述符。

段|段选择符|Base|G|limit|S|Type|DPL
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
用户代码段|__USER_CS|0x0|1|0xffffffff|1|10|3
用户数据段|__USER_DS|0x0|1|0xffffffff|1|2|3
内核代码段|__KERNEL_CS|0x0|1|0xffffffff|1|10|2
内核代码段|__KERNEL_DS|0x0|1|0xffffffff|1|2|2

对于所有的进程，它们都共享这些段描述符。这里的Base全为0，其实就相当于给出的逻辑地址的偏移就是线性地址，相当于分段单元的地址转换没有使用，Linux只是为了其平台特性而设置的。

这样这里的段仅有一个提供特权级保护和读写保护的作用，进程需要在内核态执行，内核就必须把CS或者DS、SS设置为相应的段选择符，从而设置CPU的特权级

## || Linux LDT

# 硬件中的分页

80386之后的处理器都支持分页，`cr0`寄存器中的PG标志位决定是否启用。PG=0，线性地址直接被解释为物理地址，PG=1启用分页。

## || 常规分页（32位）

从80386开始的CPU都使用4KB大小的页，并采用二级页表做常规分页，第一级被称为页目录，第二级称为页表。
每个活动进程都有一个页目录（实际一页物理页即可），但实际页表（二级页表）只有在进程需要时才分配。`cr3`寄存器中存放页目录的**物理地址**

> 除了实际需要时才分配页表，若内核只为进程分配一段虚拟内存地址空间
> 除了这段空间对应的页目录项，其他页目录项统一置为0，这样当进程访问超出该地址空间的值
> 时同样会产生缺页异常，此时内核就能知道其超界了。

32位的线性地址分为三部分

Directory|Table|Offset
:-:|:-:|:-:
高10位|中10位|低12位
页目录索引|页表索引|页内偏移

页表项/页目录项均为4个字节，其字段含义基本相同。
字段名|描述
:-:|:--
Present标志位|1则表示当前页在内存中，0则表示不在内存中此时其余的字段可由操作系统自由使用。当执行地址转换时，如果present=0，则会将此线性地址放入cr2中，并产生缺页异常
Field(20位字段)|用于存储物理页框地址
Accessed标志位|分页单元寻址到了对应的页框，就会设置该位，但不负责重置。重置需要OS处理
Dirty标志位|只用于页表项，当页框被写入过内容，将会被分页单元置为1，同样不负责重置。
Read/Write标志位|0表示页或者页表页只读，1表示可读写
User/Supervisior标志位|0表示需要特权级小于3，对于Linux来说只能内核态才能对页寻址，1表示任意特权级均可对页寻址
PCD标志位|Page Cache Disable，是否对该页框禁用cache
PWT标志位|Page Write-Through，cahe写回策略，0为回写，1为通写
Global标志位|只能用于页表项，需要在cr4寄存器中启用PGE标志，用来防止常用页被刷出TLB
Page Size标志位|用来扩展分页的大小为2MB（PAE）或4MB（PSE)，只用于页目录项

## || 扩展分页大小（PSE，Page Size Extension）

将页大小扩展为4MB，此时页目录项直接指向实际的页框。
物理地址只需分为两块：

页目录索引|页内偏移
:-:|:-:
高10位|低22位

相当于把一个页表对应的1024个页组成了一个大页。
此时页目录项中的物理地址，只有高10位有意义表示实际页框地址，因为此时页内偏移就用去了22位。
需要启用`cr4`中的PSE标志，才能扩展页和常规页一起混用。

## || 物理地址扩展分页机制 （PAE，Physical Address Extension）

32位的地址线理论上支持4GB的内存，但由于用户进程线性地址空间的需要，内核不能直接对1GB以上的内存寻址。并且大型服务器，需要4GB以上的内存。
> 关于内核必须占用1GB的虚拟地址空间的说明见下文-Linux分页

故Intel从奔腾Pro开始，将地址线引脚改为36位，将可支持的RAM增加到了64GB。

> 奔腾pro引入PAE，奔腾他三引入PSE。但Linux中并不使用PSE。

激活cr4中的PAE标志启用，若此时设置页目录项中的PageSize标志位，将启用2MB页（注意不是4MB，cr4中的PSE也未启用）

Intel为了支持PAE，采用了新的类三级页表。
因为对于4KB页而言，此时64GB会被分为2^24个页框，也就是说物理页框地址变为了24位，此时将导致页表项中Field字段无法存储物理地址，Intel将页表项扩展为了64位，但此时4KB页能容纳的页表项减少了一倍，故此时两级分页已无法满足。
Intel引入了一个页目录指针表（PDPT）作为新的一级表（此表只需要4个64位表项即可）。
此时cr3中存放的是PDPT的首地址，由于PDPT在RAM前4GB中，且基于32位对齐，故cr3中采用了27位存储该首地址。

尽管扩展了地址线，但进程使用的线性地址仍然是32位（但允许内核使用全部64GB地址）
具体的32线性地址分段含义如下：

* 对于4KB页（PS=0）
31-30|29-21|20-12|11-0
:-:|:-:|:-:|:-:
PDPT表项索引|页目录项索引|页表项索引|页内偏移

* 对于2MB页（PS=1）
类似上一节的PSE，直接将后21位作为页内偏移，不使用最后一级页表即可
31-30|29-21|20-0
:-:|:-:|:-:
PDPT表项索引|页目录项索引|页内偏移

## || 64位系统中的分页

大多数64位的CPU都不会全部使用64位，那样对于4KB的页需要的很多级的页表，并且也不需要那么大的内存空间。
一些64位系统采用的分页级别和寻址位数
平台|页大小|寻址使用位数|分页级别
:-:|:-:|:-:|:-:
alpha|8KB|43|3
ia64|4KB|39|3
x86_64|4KB|48|4

## || 硬件高速缓存

和计组中介绍的cache原理基本相同。
cache一般采用N路组相联的方式即直接相联和全相联的折中，物理地址分为三块，最后一块表示行内偏移，中间块表示直接相联的组索引，最高的块用来作为标记在组内匹配行（全相联存储器）。
无论有几个cache，Linux都忽略这些硬件细节并假定只有一个cache

### cache写策略与分页

cache的写策略分为通写和回写，通写就是改变cache中行内容时也修改RAM对应的行内容，回写就是只写cache不管RAM，但是可以通过CPU指令，或者硬件发出信号（一般cache未命中时）将行写回RAM。

奔腾CPU，还可以通过页表项中的标志位控制cache写策略，PCD（Page Cache Disable）即当访问这个页表项对应的页框时是否要禁用cache。PWT（Page Write-Through）即当写数据到该页框时采用通写还是回写策略。Linux中将PCD和PWT全置为0，表示全部页框均启用cache，均采用回写策略。
> 由于其采用回写策略，当页框对应的页需要调出内存时，就需要让CPU执行cache回写指令

### 多处理器高速缓存侦听

多处理器中每个处理器都有一个cache，此时一个cpu写入了其cache，必须要侦听其他cpu的cache中是否包含相同的内存单元，如果有需要保证cache的同步。
值得庆幸的时，这些都是由硬件完成，内核无需关心

## || TLB（快表、转换后援缓冲器）

TLB的内容和操作系统教材中的介绍一致，通过缓存已计算过的物理地址，用来加快线性地址到物理地址的转换速度。

当CPU的cr3寄存器被更新后，意味着新的页表被启用（一般是进程切换），此时**硬件**自动将TLB表项标记位失效。

在多处理器中每个CPU都有自己的TLB叫做本地TLB。

# Linux中的分页

Linux中采用4级分页模型，但根据硬件平台的不同会只用其中的一部分。
* 页全局目录
* 页上级目录
* 页中间目录
* 页表

80x86 32平台举例，线性地址的位数对应的目录

PAE|页全局目录|页上级目录|页中间目录|页表|页内偏移
:-:|:-:|:-:|:-:|:-:|:-:
ON|高2位|0位|9位|9位|12位
OFF|高10位|0位|0位|10位|12位
\* |PGDIR_SHIFT|-|-|-|-
\* |\*|PUD_SHIFT|-|-|-
\* |\*|\*|PMD_SHIT|-|-
\* |\*|\*|\*|PAGE_SHIFT|-
> `-`对应的位数累加则是对应的宏的表示的位数

具体宏和相关函数的含义见P64

## || 物理内存布局  

整个物理内存地址空间并非任何地址都可以提供给OS使用。BIOS本身例程需要需要、BIOS的数据结构需要、其他的各类BIOS ROM。
当启动时内核会询问BIOS具体的物理地址区域映射，确定其可以使用的区域。
> BIOS上电自检（POST,Power-On Self-Test）是会读取各类硬件信息

若BIOS无法提供这类地址映射，内核按照保守的缺省值确定可使用的范围。

各个硬件平台配置不同，Linux内核一般从`0x00100000`即1MB的位置开始存放内核。

## || 进程页表

进程的线性地址空间非为两部分
* 0x00000000-0xbfffffff，为用户态内核均可寻址
* 0xc0000000-0xffffffff，为内核态可寻址，也即使内核空间

故此对于页全局目录来说，0xc0000000之前的目录项为每个进程所特有的（对应实际的进程私有空间），之后的项其实是所有进程都是相同的，对应于内核空间。
> 即PAE开启时，前3项为进程所特有，最后一项所有进程都相同。PAE关闭，则是前768项为各进程特有。

> PAE关闭时，线性地址分为10/10/12，对于后22位全为0的地址比如这里的0xc0000000简写为0x300（前10位的hex），其为2^22的倍数，因为0xc0000000=0x300*2^22即通过左移22位得到，也是2^22的倍数。
同时对于地址空间的分块而言，0x300表示的块大小就是2^22，并且其中0xc0000000是该块中的第一个字节地址。
对于页全局目录而言，0x300前面就是0x300块即768

### 内核占用1GB虚拟地址空间的讨论

首先会想到为何不把4GB虚拟地址全部分配给进程？

如果全分配，但由于内核也采用非连续分配方式（分页，提高内存利用率），内核也需要页表，需要虚拟地址空间。 那么在每次执行内核代码的时候就必须切换页表（即重设cr3中页表地址），避免内核代码虚拟地址和进程空间的冲突。但这样做有两点缺点：
1. 切换页表会导致TLB失效，而中断和异常又十分的常见，应该会导致显著的性能下降
2. 80x86提供硬件中断流程中不处理页表，必须要OS切换

故，Linux选择牺牲一部分进程虚拟地址空间，用来简化处理。而且从内核代表进程运行的语义上来说，进程页表中存在内核虚拟地址映射也说的过去。



## || 内核页表???

从上一节可知，线性地址的高1GB地址存放内核，这部分地址空间对应的页全局目录项，每个进程均相同。
这些目录项和页表，由内核在系统初始化时维护（此时所有内存空间都没被使用），建立该内核页表也称为主内核页全局目录。
> 第八章将解释如何将对内核页表的修改，传递给进程的页表

### 内核如何初始化内核页表

首先内核按照前面的讨论，应该放在物理地址`0x00100000`处，按照内核代码段、内核已初始化的数据段、内核未初始化的数据段的顺序存放。

而内核实际工作的线性地址空间是从`0xc0000000`开始的，所以内核最终完成了初始化之后，内核页表需要提供将从`0xc000000`开始的线性地址空间映射到从`0`开始的物理地址上。
> 注意整个`0-0x3fffffff`的1GB的物理地址空间都映射到来线性地址空间，而不仅是从`0x00100000`开始的内核。

在内核刚刚在加载到内存中时，此时CPU还工作在实模式下，此时需要逐步过渡到保护模式，所以内核提供了临时页表。之后再建立最终的内核页表。

### 临时内页表

这里假设刚加载时的内核、临时页表、内核使用段都在前8MB之类，所以这个过渡阶段，需要先提供这8MB的页表映射。
此时为了在开启分页单元之后，实模式和保护模式都能对这8MB寻址，需要将两块线性地址都映射到前8MB的物理地址空间。这两块线性地址空间分别是用于实模式的`0-0x003fffff`和用于保护模式的`0xc0000000-0xc03fffff`

临时页全局目录`swapper_pg_dir`是在内核编译中静态初始化的，而临时页表是由`startup_32`汇编函数初始化的。

内核把`swapper_pg_dir`中的0和0x300项的物理地址字段设置为pg0（即内核映像后的第一个页框地址），1和0x301项的物理地址字段设置为pg1，其他的目录项置为0。

然后将`swapper_pg_dir`的地址装入cr3，并开启cr4的分页标志位。

> 注意此处的pg0没有说这个页框是4kB的页表还是4MB的页
> 如果是页表，则还需要初始化页表项

### 最终内核页表
