---
title: "基础知识 寄存器与简单指令"
date: 2022-06-19T15:16:48+08:00
topics: "linux-kernel"
draft: true
---

# 8086内存布局

地址段|含义
:-:|:--
00000-9FFFF|主存地址空间
A0000-BFFFF|显存RAM空间
C0000-FFFFF|各类设备BIOS ROM地址空间

# 寄存器简介

程序员通过控制寄存器来实现对CPU的控制，从这样看，此时寄存器就像普通的设备控制器的接口一样。
**使用寄存器的必要性？**
这是实现CPU的功能所必须的（冯诺伊曼体系结构规定的功能）。
比如：

* 需要PC寄存器保存当前程序的执行位置
* 需要IR寄存器缓存指令
* 需要通用寄存器暂存操作数（总线只有一条，一次只能给出一个操作数）
* 需要SS段寄存器保存地址等

其次自然也有缓冲数据，减缓速率不匹配的问题。

# 通用寄存器

8086CPU的所有寄存器都是16位的。
其中ax、bx、cx、dx通常用来存放一般性数据被称为通用寄存器。

> 当然某些指令也使用这些寄存器作为隐藏操作数

为了保证和上一代CPU的兼容，这4个通用寄存器也支持拆分为两个8位寄存器单独使用。
如：`al`表示`ax`的低8位，`ah`表示高8位。剩余3个寄存器同理。
> 注意拆分过后，CPU是完全把其当作独立的寄存器考虑的
> 如：`add al, 93h`就算会产生进位，也不会将进位放在`ah`，只会放在PSW中。

# 几条简单的汇编指令

指令|含义
:-:|:--
mov ax, 18|将18送入ax
mov ah, 78|将78送入ah
add ax, 8|ax=ax+8
mov ax, bx|ax=bx
add ax, bx|ax+=bx
sub ax, bx|ax-=bx
> 注意进行运算或者传送时，两个操作数的位数必须一致
> 所有的语法都是基于masm编译器的标准

# 分段与8086给出物理地址方法

8086是16位寄存器，表示一次性只能处理16的数据。
但其支持的地址线数位20位，故采用了特殊的方法给出20位地址。
**物理地址=段地址x16+偏移地址**
也可以表示为段地址左移4位后加上偏移地址

> 其中段地址和偏移地址都是16位的寄存器分别为CS、IP
> 故一个段最多只有64KB

注意程序分段与8086的硬件特性表示的分段，这其实是两回事。
程序分段其实是具有和硬件无关的一些优点，有如下的特点：

* 便于程序设计与数据管理
* 便于为段指定属性，只读，可读写等，方便共享
* 方便重定位，静态重定位只需要对段地址重定位即可，其他均为相对地址。
* 便于共享，比如代码段
* 提高CPU缓存命中率，提供代码段和数据段将代码数据分离。

# 段寄存器

8086使用段寄存器为程序分段提供了便利。

## || CS、IP
`CS`为代码段寄存器，`IP`为指令寄存器，如上所属`CSx16+IP`就构成了CPU下一条要执行的指令地址。

> 注意当前指令一旦读入CPU后，IP就会自动累加。
> 所以当前指令执行时，IP指向的是下一条指令的位置

CPU上电后自动设置`CS=FFFFH`，`IP=0000H`，从此处开始执行。

### 修改CS、IP
**只能**使用跳转相关的指令修改CS和IP的值。
如:

* jmp reg，设置ip=reg
* call label等
> 不能使用mov指令修改
> 详情见转移指令一文

## || DS和[address]

### 内存中字的存储
8086采用的是小端字节序，即对于一个16位的字而言，字低8位存放在低地址，字高8位存放在高地址。

### DS
DS寄存器用于存放要访问数据的段地址
```asm
mov bx, 1000H
mov ds, bx
mov al, [0] ; mov al, ds:[0]
```
需要注意，段寄存器不能通过`mov`指令直接传送字面常量，必须要通过一个通用寄存器中转。
对于`mov al, [0]`自动将`ds`作为段寄存器，0作为偏移地址，将内存中**一个字节**传送到al

> 注意al指定了传送的数据长度，如果为ax则传送一个字
> `mov ax, [0]`表示将bs:[0]到ax低8位，bs:[1]到ax高8位

使用示例
```asm
mov al, [0]
mov bx, [0]
mov [0], bx
add bx, [0]
add [0], bx
sub ax, [0]
```
> masm编译器其实是不认`mov al, [constant]`这种写法的
> 对于常量内存地址必须要显式给出段前缀`mov al, ds:[constant]`

## || SS、SP

8086使用SS和SP寄存器使用栈段，SS表示段地址，SP指向栈顶。
通过`push`和`pop`指令实现入栈和出栈，`push`和`pop`都是以16位字为传送单位的。
8086实现的入栈是由高地址往低地址生长的。
故`push ax`表示先`SP=SP-2`，然后在传送ax到SS:SP
`pop ax`则表示先传送到SS:SP到ax，然后`SP=SP+2`
记住SS:SP任何时候都是指向栈顶的。

> 注意8086并不保证不会出现栈定超界（即栈满再push，栈空再pop）

用法示例
```asm
mov ax, 1000H
mov ds, ax
mov ss, ax
mov sp, 64

push ax
pop ax

push cs
push ip

push [0]
pop [0]
```
> `push`和`pop`指令是支持类型比较多的传送指令，包括通用寄存器、段寄存器、内存单元
> 这和栈在程序中特殊意义有关，即需要保存现场，自然需要支持段寄存器

还有一点需要特别注意，**当执行修改`SS`栈段寄存器时，其下一条指令会被CPU紧跟着执行**。此处的**紧跟着**表示的是不会被中断。
原因是，修改`SS`指令紧跟着的指令一般为修改`SP`，而中断需要保存断点即CS、IP以及PSW到当前栈中，如果此时被中断，会导致断点存储位置出错。

# masm基本语法

```asm
seg_name segment
start:
	mov ax, bx
	mov bx, ax
	;;;;
	mov ax, 4c00h
	int 21h
seg_name ends
end start 
```
需要注意的是，当程序结束时必须手动通知系统（调用系统调用，`int 21h`），不然CPU可不知道什么时候结束，它只会一致执行指令直到超出当前程序的范围。

> masm中非段名的标号，其实是在编译期就确定了的，相对于段首偏移常量，表示标号所在位置的指令的首字节的偏移位置