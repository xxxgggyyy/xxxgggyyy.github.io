---
title: "结构体对齐与结构体大小"
date: 2023-11-10T14:30:55+08:00
topics: "c-family"
draft: false
summary: "C结构体对齐"
---

# 对齐值确定

> 对齐值为变量的按照某个大小的字节倍数地址对齐

```cpp
struct AlignTest{
    char a;
    double b;
} 
```

先说结论：结构的对齐值为最大的成员对齐值，这里也就是按8字节对齐。

因为如果结构体按照char的1字节对齐，那么由于b始终需要按照8字节对齐，那么将导致a和b之间的padding大小无法确定。

```
|
a-------b
---a----b
```

即结构体放的位置不同，将导致a和b之间的padding不同（应为b始终需要对齐）。

按照最大的对齐值对齐则没有这个问题，比如这里按照8对齐，将导致a始终在8的倍数的地址，从而保证b和a之间的paading一致。

# 结构体大小

注意，结构体大小受成员的顺序影响。

```cpp
struct A{
    int a;
    double b;
    char c;
}

struct B{
    double a;
    int b;
    char c;
}
```

其中`sizeof(A)`为24字节，而`sizeof(B)`为16字节。可见顺序对结构体的影响之大。

在A和B的内存结构如下：

```shell
[ int a ][ padding 4B ][ double b ][ char c ][ padding 7B ]
```
首先a是放在一个8对齐的地址上的，所以放b的时候需要4b的对齐，完了放c，但是结构体的对齐为8（考虑数组中，那么结构体必须为8的倍数，因为下一个元素始终要放在8的倍数上），所以需要7b的padding补齐。所以整体大小达到了24B

```sh
[ double a ][ int b ][ char c ][ padding 3B ]
```
这里同理，但是只需要c后面补齐3b就是8的整体对齐，所以非常紧凑只有16B。所以说严格按照从大到小的顺序的声明成员变量，一定会有最紧凑的内存格式。

因为整体的对齐值是按照最大的来的，那么第一个放最大的成员，第二个成员同样在最大对齐值上（地址），并且一般成员对齐值都是2的幂次，故大的对齐值一定满足小的对齐值(比如8的倍数一定是4的倍数)，所以一定可以直接放第二个成员，不用padding。

从大到小排，一定具有最小的填充。

> 可反证，如果还有一种更小的填充，那整个结构体一定更小，而结构体本身是要求对齐的，故这个更小的结构体，一定比此时小对齐值的倍数。但由上有可知，从大到小排列最多只在末尾填充`对齐值-1`，所以如果存在更小的结构体，至少会小对齐值，这比把所有成员大小直接加一起还小，根本不可能存放下这个结构体，故矛盾。
