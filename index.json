[{"content":"","date":"3 March 2024","permalink":"/topics/algorithms-and-data-structures/","section":"Topics","summary":"","title":"Algorithms and Data Structures"},{"content":"","date":"3 March 2024","permalink":"/topics/c-family/","section":"Topics","summary":"","title":"C Family Languages"},{"content":"","date":"3 March 2024","permalink":"/topics/linux-basis/","section":"Topics","summary":"","title":"Linux Basis"},{"content":"UNIX初级教程 - Unix Unbounded: A Beggining Approach\n","date":"3 March 2024","permalink":"/series/unix-unbounded/","section":"Series","summary":"UNIX初级教程 - Unix Unbounded: A Beggining Approach","title":"Unix Unbounded"},{"content":" ","date":"3 March 2024","permalink":"/","section":"Blogs","summary":" ","title":"Blogs"},{"content":" 各种各样的技术相关博客（或许）以及笔记 - Linux、C/C++、GO、Rust、分布式系统、数据库、操作系统\u0026hellip;\u0026hellip; ","date":"3 March 2024","permalink":"/posts/","section":"Blogs","summary":" 各种各样的技术相关博客（或许）以及笔记 - Linux、C/C++、GO、Rust、分布式系统、数据库、操作系统\u0026hellip;\u0026hellip; ","title":"Blogs"},{"content":" 读书笔记和各种成系列的笔记 ","date":"3 March 2024","permalink":"/series/","section":"Series","summary":" 读书笔记和各种成系列的笔记 ","title":"Series"},{"content":" 读书笔记和各种成系列的笔记 ","date":"3 March 2024","permalink":"/topics/","section":"Topics","summary":" 读书笔记和各种成系列的笔记 ","title":"Topics"},{"content":"","date":"2 March 2024","permalink":"/tags/leetcode/","section":"Tags","summary":"","title":"Leetcode"},{"content":" Leetcode Problems # 438. 找到字符串中所有字母异位词 # https://leetcode.cn/problems/find-all-anagrams-in-a-string\n给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n异位词 指由相同字母重排列形成的字符串（包括相同的字符串）。\n题解\n经典滑动窗口问题。 这里先放个官方题解：\nclass Solution { public: vector\u0026lt;int\u0026gt; findAnagrams(string s, string p) { int sLen = s.size(), pLen = p.size(); if (sLen \u0026lt; pLen) { return vector\u0026lt;int\u0026gt;(); } vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; sCount(26); vector\u0026lt;int\u0026gt; pCount(26); for (int i = 0; i \u0026lt; pLen; ++i) { ++sCount[s[i] - \u0026#39;a\u0026#39;]; ++pCount[p[i] - \u0026#39;a\u0026#39;]; } if (sCount == pCount) { ans.emplace_back(0); } for (int i = 0; i \u0026lt; sLen - pLen; ++i) { --sCount[s[i] - \u0026#39;a\u0026#39;]; ++sCount[s[i + pLen] - \u0026#39;a\u0026#39;]; if (sCount == pCount) { ans.emplace_back(i + 1); } } return ans; } }; 其中sCount就表示在s上滑动窗口中字符串的情况，每次滑动一个去和p比较即可。当然这里的比较方法和滑动都比较原始。\n官方题解还有一个去统计differ而不用维持两个数组的方法，这里没有再说了。\n再来看我的，我最开始没想到什么滑动窗口，所以是直接写的。（但思想和滑动窗口一样）\n但我和官解最不同的在于，我添加了快速滑动。主要思想也比较简单，就是不要一个一个去滑了，比如检测到一个不在p中的k字符，那么直接可以从k之后再开始比较。还有就是如果是在窗口内检测到字符m虽然在p内，但多了，那么再开始滑动从第一个m开始，并且重新计算统计状态。\n当然这里的代码写得很烂，这么多变量非常容易出错。可以只做检测到不同的快速滑动，其他的干脆就让他重新统计，这样虽然会牺牲一些性能，但简单很多。\nclass Solution { public: vector\u0026lt;int\u0026gt; findAnagrams(string s, string p) { vector\u0026lt;int\u0026gt; ret; if(s.size() \u0026lt; p.size()) return ret; // unordered_map\u0026lt;char, int\u0026gt; need, window; int need[26], window[26]; memset(need, 0, sizeof(need)); for (char c : p) { need[c - \u0026#39;a\u0026#39;]++; } // window = need; memcpy(window, need, sizeof(need)); bool continueFlag = false; int j = -1; int count = 0; for(int i = 0; i \u0026lt; s.size();i++){ if(need[s[i]-\u0026#39;a\u0026#39;] == 0){ continue; } if(!continueFlag){ j = i; count = 0; } continueFlag = false; for(; j \u0026lt; i + p.size(); j++){ // not found if(need[s[j] - \u0026#39;a\u0026#39;] == 0){ i = j; memcpy(window, need, sizeof(need)); break; } // repeated character exceed the need if(window[s[j] - \u0026#39;a\u0026#39;] == 0){ while(s[i] != s[j]){ window[s[i] - \u0026#39;a\u0026#39;]++; i++; count--; } continueFlag = true; j++; // cur_start = i; break; } window[s[j] - \u0026#39;a\u0026#39;]--; count++; } // using separate count var to avoid corner case which the j is the last character in continueFlag=true // if(j == i + p.size()){ // ret.push_back(i); // window = need; // } if(count == p.size()){ ret.push_back(i); continueFlag = true; window[s[i] - \u0026#39;a\u0026#39;]++; count--; } } return ret; } }; 448. 找到所有数组中消失的数字 # https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array\n给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字，并以数组的形式返回结果。\n题解\nclass Solution { public: vector\u0026lt;int\u0026gt; findDisappearedNumbers(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for(int i = 0;i \u0026lt; nums.size();i++){ if(nums[i] == 0) continue; int j = nums[i] - 1; while(nums[j] != 0){ int tmp = nums[j]; nums[j] = 0; j = tmp - 1; } } vector\u0026lt;int\u0026gt; ret; ret.reserve(nums.size() / 2); for(int i = 0;i \u0026lt; nums.size();i++){ if(nums[i] != 0){ ret.push_back(i+1); } } return ret; } }; 主要是要想到利用原地数组作为hash数组。对于复用原地数组的一个较好的方案不是想我这里去改成0，然后循环处理，而是可以存成负值。\n461. 汉明距离 # https://leetcode.cn/problems/hamming-distance\n两个整数之间的 汉明距离 指的是这两个数字对应二进制位不同的位置的数目。\n给你两个整数 x 和 y，计算并返回它们之间的汉明距离。\n题解\nclass Solution { public: int hammingDistance(int x, int y) { x = x ^ y; int count = 0; while(x){ count += x \u0026amp; 1; x = x \u0026gt;\u0026gt; 1; } return count; } }; 异或加移位统计即可。\n1400. 构造 K 个回文字符串 # https://leetcode.cn/problems/construct-k-palindrome-strings\n给你一个字符串 s 和一个整数 k 。请你用 s 字符串中 所有字符 构造 k 个非空 回文串 。\n如果你可以用 s 中所有字符构造 k 个回文字符串，那么请你返回 True ，否则返回 False 。\n题目\n这道题的解法比较巧，没想到就没想到。主要利用回文字符串的性质。\n先统计s中每个字符的次数，奇数次数的，多出来的那个必须作为回文字符串的中心。\n设r = k - odd，即题目的k减去其中的奇数字符：\nr == 0，刚好k个中心，还有剩余的偶数次字符可以随便附加到某个中心上 r \u0026lt; 0，奇数次数比k多，使用s的全部字符至少会得到比k多的回文串，不满足要求 r \u0026gt; 0，也返回true 对于第三点，由于s \u0026gt;= k，去掉小于k个奇数中心后，剩下的s-k+r \u0026gt;= r且是偶数（因为奇数全部用了）\n当r是偶数时，从s-k+r中取r个中心，还剩偶数个字符随意附加。\n当r是奇数时，从s-k+r中取r-1中心，还剩偶数，直接构成剩余的。\n所以均成立。\n215. 数组中的第K个最大元素 # https://leetcode.cn/problems/kth-largest-element-in-an-array\n给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。\n请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。\n你必须设计并实现时间复杂度为 O(n) 的算法解决此问题。\n题解\n快速选择没啥好说的。\nclass Solution { public: int ik; int ret; int findKthLargest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { ik = nums.size() - k; _findKth(nums, 0, nums.size() - 1); return ret; } void _findKth(vector\u0026lt;int\u0026gt;\u0026amp; nums, int s, int e){ int pivot = nums[s]; int i = s, j = e; while(i \u0026lt; j){ while(nums[j] \u0026gt;= pivot \u0026amp;\u0026amp; i \u0026lt; j) j--; nums[i] = nums[j]; while(nums[i] \u0026lt;= pivot \u0026amp;\u0026amp; i \u0026lt; j) i++; nums[j] = nums[i]; } nums[i] = pivot; if(i \u0026lt; ik){ _findKth(nums, i + 1, e); }else if(i \u0026gt; ik){ _findKth(nums, s, i - 1); }else{ ret = nums[i]; } } }; 但似乎测试用例中有一个非常奇怪的用例，如果选择nums[s]为pivot会导致时间复杂度退化，导致非常耗时。\n所以，可以其他的pivot选择策略，比如三值取中。\n27. 移除元素 # https://leetcode.cn/problems/remove-element\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n题目\n由于元素顺序可以改变，所以可以很快，直接用尾部的去填写就可以了。\nclass Solution { public: int removeElement(vector\u0026lt;int\u0026gt;\u0026amp; nums, int val) { int tail = nums.size() - 1; for(int i = 0; i \u0026lt; nums.size() \u0026amp;\u0026amp; i \u0026lt;= tail; i++){ if(nums[i] == val){ while(nums[tail] == val \u0026amp;\u0026amp; tail \u0026gt; i){ tail--; } nums[i] = nums[tail--]; } } return tail + 1; } }; 26. 删除有序数组中的重复项 # https://leetcode.cn/problems/remove-duplicates-from-sorted-array\n给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。\n考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：\n更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。 返回 k\n题解\n注意到数组本身是排序的，所以就很简单了。\nclass Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int val = nums[0], head = 1; for(int i = 1; i \u0026lt; nums.size(); i++){ if(nums[i] != val){ nums[head++] = nums[i]; val = nums[i]; } } return head; } }; 80. 删除有序数组中的重复项 II # https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii\n给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次 ，返回删除后数组的新长度。\n不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n题解\n才做完上一题，解法完全相同。\nclass Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int val = nums[0], head = 1; if(nums.size() \u0026gt; 1 \u0026amp;\u0026amp; val == nums[1]){ head++; } for(int i = head; i \u0026lt; nums.size(); i++){ if(nums[i] != val){ nums[head++] = nums[i]; val = nums[i]; if(i+1 \u0026lt; nums.size() \u0026amp;\u0026amp; nums[i+1] == val){ nums[head++] = nums[i]; } } } return head; } }; 189. 轮转数组 # https://leetcode.cn/problems/rotate-array\n给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。\n题解\n看似很简单，如果要求使用原地数组，且时间复杂度为O(n)则显得麻烦。\n这里使用三段反转的方式。向右移动k则和k mod n是一样的，故一定是k mod n个末尾字段到了数组头，数组前面的到了数组尾部。\nclass Solution { public: void rotate(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { int real_k = k % nums.size(); if(real_k == 0) return; reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin() + real_k); reverse(nums.begin() + real_k, nums.end()); } }; 到这里都很简单。但还有一种循环替代法，这种也是比较直观的做法。\n但证明非常麻烦\n没证出来:(\n假设从nums[0]开始直接往最终位置放，放了之后的那个位置再往它的最终位置。\n设real_k = k mod n，那么nums[0]回到自身时，一定是real_k和n的最小公倍数s，则有s/real_k表示一轮确定的数量。\nn / (s/real_k)为需要迭代的轮次即real_k和n的最大公约数。\n274. H 指数 # https://leetcode.cn/problems/h-index\n给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。\n根据维基百科上 h 指数的定义：h 代表“高引用次数” ，一名科研人员的 h 指数 是指他（她）至少发表了 h 篇论文，并且 至少 有 h 篇论文被引用次数大于等于 h 。如果 h 有多种可能的值，h 指数 是其中最 大的那个。\n题解\n最简单的做法，即先排序再找。\nclass Solution { public: int hIndex(vector\u0026lt;int\u0026gt;\u0026amp; citations) { sort(citations.begin(), citations.end(), greater\u0026lt;int\u0026gt;()); int i = 1; for(; i \u0026lt;= citations.size(); i++){ if(citations[i-1] \u0026lt; i){ break; } } return i - 1; } }; 官方题解中，有种方法是O(n)，即先维持一个计数器数组counter[n]，直接看代码。\nclass Solution { public: int hIndex(vector\u0026lt;int\u0026gt;\u0026amp; citations) { int n = citations.size(), tot = 0; vector\u0026lt;int\u0026gt; counter(n + 1); for (int i = 0; i \u0026lt; n; i++) { if (citations[i] \u0026gt;= n) { counter[n]++; } else { counter[citations[i]]++; } } for (int i = n; i \u0026gt;= 0; i--) { tot += counter[i]; if (tot \u0026gt;= i) { return i; } } return 0; } }; 380. O(1) 时间插入、删除和获取随机元素 # https://leetcode.cn/problems/insert-delete-getrandom-o1\n实现RandomizedSet 类：\nRandomizedSet() 初始化 RandomizedSet 对象 bool insert(int val) 当元素 val 不存在时，向集合中插入该项，并返回 true ；否则，返回 false 。 bool remove(int val) 当元素 val 存在时，从集合中移除该项，并返回 true ；否则，返回 false 。 int getRandom() 随机返回现有集合中的一项（测试用例保证调用此方法时集合中至少存在一个元素）。每个元素应该有 相同的概率 被返回。 你必须实现类的所有函数，并满足每个函数的 平均 时间复杂度为 O(1)\n题目\n这道题无趣得很，必须要用随机函数才行。另外这题的一些边界条件需要注意一下，比如删除的末尾的元素。\nclass RandomizedSet { public: unordered_map\u0026lt;int, int\u0026gt; mp; vector\u0026lt;int\u0026gt; vec; RandomizedSet(){ srand((unsigned)time(NULL)); } bool insert(int val) { if(mp.count(val)){ return false; } vec.push_back(val); mp[val] = vec.size() - 1; return true; } bool remove(int val) { if(!mp.count(val)){ return false; } int inx = mp[val]; vec[inx] = vec.back(); mp[vec[inx]] = inx; vec.pop_back(); mp.erase(val); return true; } int getRandom() { return vec[rand()%vec.size()]; } }; 12. 整数转罗马数字 # 罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。\n字符 数值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。\n通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 给你一个整数，将其转为罗马数字。\n题解\n直接按照基数来就行了：\nconst pair\u0026lt;int, string\u0026gt; roman_radix[] = { {1000, \u0026#34;M\u0026#34;}, {900, \u0026#34;CM\u0026#34;}, {500, \u0026#34;D\u0026#34;}, {400, \u0026#34;CD\u0026#34;}, {100, \u0026#34;C\u0026#34;}, {90, \u0026#34;XC\u0026#34;}, {50, \u0026#34;L\u0026#34;}, {40, \u0026#34;XL\u0026#34;}, {10, \u0026#34;X\u0026#34;}, {9, \u0026#34;IX\u0026#34;}, {5, \u0026#34;V\u0026#34;}, {4, \u0026#34;IV\u0026#34;}, {1, \u0026#34;I\u0026#34;}}; class Solution { public: string intToRoman(int num) { string ret; int radix = 0; while(num \u0026gt; 0){ for(;radix \u0026lt; 13; radix++){ if(roman_radix[radix].first \u0026lt;= num) break; } while(num \u0026gt;= roman_radix[radix].first){ num -= roman_radix[radix].first; ret.insert(ret.end(), roman_radix[radix].second.begin(), roman_radix[radix].second.end()); } } return ret; } }; 134.加油站 # https://leetcode.cn/problems/gas-station\n在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。\n你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。\n给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的\n题解\n最容易想到的是暴力做法，从每个点出发都去模拟一下，即到达每个点时都有gas_sum \u0026gt;= cost_sum，则一定可以走到下一个位置。但时间为O(n^2)，会超时。\n但可以观察到，如果从i点出发，走到j点时出现了gas_sum \u0026lt; cost_sum则无法走到j+1加油站，而由于在i~j之间的加油站都有gas_sum \u0026gt;= cost_sum\n所以从i+1~j的任意加油站出发都会在j点出现gas_sum \u0026lt; cost_sum故可以直接从j+1开始下一次模拟。时间复杂度下降到O(n)\nclass Solution { public: int canCompleteCircuit(vector\u0026lt;int\u0026gt;\u0026amp; gas, vector\u0026lt;int\u0026gt;\u0026amp; cost) { int gas_sum = 0, cost_sum = 0; bool found = true; for(int i = 0;i \u0026lt; gas.size(); ){ found = true; gas_sum = cost_sum = 0; for(int j = 0; j \u0026lt; gas.size(); j++){ int real_j = (i + j) % gas.size(); gas_sum += gas[real_j]; cost_sum += cost[real_j]; if(gas_sum \u0026lt; cost_sum){ i = i + j + 1; found = false; break; } } if(found){ return i; } } return -1; } }; 58.最后一个单词的长度 # https://leetcode.cn/problems/length-of-last-word\n给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。\n单词 是指仅由字母组成、不包含任何空格字符的最大 子字符串 子字符串 子字符串 是字符串中连续的字符序列。\n题解\n简单题，注意边界条件。\nclass Solution { public: int lengthOfLastWord(string s) { int end = -1; for (int i = s.size() - 1; i \u0026gt;= 0; i--) { if(s[i] != \u0026#39; \u0026#39;){ end = i; break; } } for(int i = end - 1;i \u0026gt;= 0;i--){ if(s[i] == \u0026#39; \u0026#39;) return end - i; } return end + 1; } }; 28. 找出字符串中第一个匹配项的下标 # https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string\n给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。\n题目\n最优做法应该是使用KMP算法。\nclass Solution { public: int strStr(string haystack, string needle) { int i = 0, j = 0; vector\u0026lt;int\u0026gt; next; calcNext(next, needle); while(i \u0026lt; (int)haystack.size() \u0026amp;\u0026amp; j \u0026lt; (int)needle.size()){ if(j == -1 || haystack[i] == needle[j]){ i++; j++; }else{ j = next[j]; } } if(j == needle.size()){ return i - j; } return -1; } void calcNext(vector\u0026lt;int\u0026gt; \u0026amp;next, string \u0026amp;str) { if (next.size() != str.size()) { next.resize(str.size()); } next[0] = -1; int j = 1, k = -1; while (j \u0026lt; str.size()) { if (k == -1 || str[j - 1] == str[k]) { next[j++] = ++k; } else { k = next[k]; } } } }; 经典KMP实现。注意-1 \u0026lt; (size_t)0竟然是false，int被提升为了无符号的size_t而不是反过来。\n字符串匹配其实可以认为是比较经典的滑动窗口问题，滑动窗口的优化一般都是一次性可以多滑动一点，而不是+1.\nKMP的方案就是通过当某个字符匹配失败时，根据已知的信息确定一个最大滑动距离。\n这里最大滑动距离通过next数组来提供，next[i]含义是在needle[0, i]中不包含needle[i]时，从后往前匹配needle从前往后中的最大匹配长度。\n68.文本左右对齐 # https://leetcode.cn/problems/text-justification\n给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。\n你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 \u0026rsquo; \u0026rsquo; 填充，使得每行恰好有 maxWidth 个字符。\n要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。\n文本的最后一行应为左对齐，且单词之间不插入额外的空格。\n题解\n这题远远算不上难题吧。\nclass Solution { public: vector\u0026lt;string\u0026gt; fullJustify(vector\u0026lt;string\u0026gt;\u0026amp; words, int maxWidth) { vector\u0026lt;string\u0026gt; ret; int i = 0, j = 0, n = words.size(); while (i \u0026lt; n) { ret.push_back(\u0026#34;\u0026#34;); string\u0026amp; line = ret.back(); line.reserve(maxWidth + 1); int line_len = words[i].size(); int real_char_num = words[i].size(); for (j = i + 1; j \u0026lt; n; j++) { line_len += words[j].size() + 1; if (line_len \u0026gt; maxWidth) { break; } real_char_num += words[j].size(); } // last line, left justify if (j == n) { append_str(line, words[i]); for (int s = i + 1; s \u0026lt; j; s++) { line.push_back(\u0026#39; \u0026#39;); append_str(line, words[s]); } if (line.size() \u0026lt; maxWidth) { append_space(line, maxWidth - line.size()); } break; } // only one word if (j - i == 1) { append_str(line, words[i]); append_space(line, maxWidth - line.size()); i = j; continue; } int evenly_space_num = (maxWidth - real_char_num) / (j - i - 1); int remain = (maxWidth - real_char_num) % (j - i - 1); append_str(line, words[i]); for (int s = i + 1; s \u0026lt; j; s++) { append_space(line, evenly_space_num); if(remain \u0026gt; 0){ append_space(line, 1); remain--; } append_str(line, words[s]); } i = j; } return ret; } void append_str(string\u0026amp; dst, string\u0026amp; str) { dst.insert(dst.end(), str.begin(), str.end()); } void append_space(string\u0026amp; dst, int num) { for (int i = 0; i \u0026lt; num; i++) { dst.push_back(\u0026#39; \u0026#39;); } } }; 167.两数之和 II - 输入有序数组 # https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted\n给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 \u0026lt;= index1 \u0026lt; index2 \u0026lt;= numbers.length 。\n以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。\n你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。\n你所设计的解决方案必须只使用常量级的额外空间。\n题解\n能明显感觉到该题是被精心设计的。\n序列是非严格递增的，而两数之和一定是一大一小（或者相等），所以可以想到双指针遍历。\n而从左边确定一个nums[i]后，从右边往下找tmp = target - nums[i]即可，如果没找到则得到一个nums[j] \u0026lt; tmp，而nums[i+1]又更大，相比nums[i]的tmp，此时他的tmp一定更小，正好可以从j开始继续找，因为刚才找的大于j的有nums[] \u0026gt; tmp1 \u0026gt; tmp2\n直接看代码：\nclass Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; numbers, int target) { int i = 0, j = numbers.size() - 1; while (i \u0026lt; j) { int tmp = target - numbers[i]; while(numbers[j] \u0026gt; tmp) j--; if(numbers[j] == tmp){ return {i+1, j+1}; } i++; } return {-1, -1}; } }; 125.验证回文串 # https://leetcode.cn/problems/valid-palindrome\n如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。\n字母和数字都属于字母数字字符。\n给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。\n题解\nclass Solution { public: bool isPalindrome(string s) { int n = s.size(); int j = n - 1, i = 0; while(i \u0026lt;= j){ while(i \u0026lt; j \u0026amp;\u0026amp; !is_ad(s[i])) i++; while(j \u0026gt;= i \u0026amp;\u0026amp; !is_ad(s[j])) j--; if(i \u0026gt; j) break; if(!ad_equal(s[i], s[j])){ return false; } j--; i++; } return true; } static inline bool ad_equal(char a, char b){ if(a == b) return true; if(is_alpha(a) \u0026amp;\u0026amp; is_alpha(b)) return abs(a - b) == abs(\u0026#39;a\u0026#39; - \u0026#39;A\u0026#39;); return false; } static inline bool is_digit(char c){ return c \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;9\u0026#39;; } static inline bool is_alpha(char c){ return (c \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;z\u0026#39;) || (c \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; c \u0026lt;= \u0026#39;Z\u0026#39;); } static inline bool is_ad(char c){ return is_digit(c) || is_alpha(c); } }; 209.长度最小的子数组 # https://leetcode.cn/problems/minimum-size-subarray-sum\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其总和大于等于 target 的长度最小的 连续 子数组 [numsl, numsl+1, \u0026hellip;, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n题解\n类似滑动窗口，但不一样。还是双指针，设i=0，然后找到第一个nums[i, j]的和大于等于target，之后在增大j，检查i是否也可增大，\n通俗来说其实是找以某个nums[i]为末尾时，大于等于target的最小长度。\nclass Solution { public: int minSubArrayLen(int target, vector\u0026lt;int\u0026gt;\u0026amp; nums) { int i = 0, j = 0; long long sum = 0; int min_len = INT_MAX; for (; j \u0026lt; nums.size(); j++) { sum += nums[j]; if (sum \u0026lt; target) continue; while (sum - nums[i] \u0026gt;= target) { sum -= nums[i]; i++; } if (j - i + 1 \u0026lt; min_len) min_len = j - i + 1; } return min_len \u0026lt; INT_MAX? min_len : 0; } }; 30.串联所有单词的子串 # https://leetcode.cn/problems/substring-with-concatenation-of-all-words\n给定一个字符串 s 和一个字符串数组 words。 words 中所有字符串 长度相同。\ns 中的 串联子串 是指一个包含 words 中所有字符串以任意顺序排列连接起来的子串。\n例如，如果 words = [\u0026ldquo;ab\u0026rdquo;,\u0026ldquo;cd\u0026rdquo;,\u0026ldquo;ef\u0026rdquo;]， 那么 \u0026ldquo;abcdef\u0026rdquo;， \u0026ldquo;abefcd\u0026rdquo;，\u0026ldquo;cdabef\u0026rdquo;， \u0026ldquo;cdefab\u0026rdquo;，\u0026ldquo;efabcd\u0026rdquo;， 和 \u0026ldquo;efcdab\u0026rdquo; 都是串联子串。 \u0026ldquo;acdbef\u0026rdquo; 不是串联子串，因为他不是任何 words 排列的连接。 返回所有串联子串在 s 中的开始索引。你可以以 任意顺序 返回答案。\n题解\n这题也很容易想到滑动窗口。\n所以暴力解法就是每次滑动一个字符即可。但这样每次都必须清空之前窗口的统计信息，无法利用单词信息。\n所以干脆以单词长度为滑动单位，此时需要改变一下滑动方式，分别以0~n-1为起始点（n为一个单词的长度），以单词长度滑动。这样和一个字符一个字符滑动遍历到的窗口是一样的多的，只是换了个顺序，使其可以利用单词信息。\n代码如下：\nclass Solution { public: vector\u0026lt;int\u0026gt; findSubstring(string s, vector\u0026lt;string\u0026gt;\u0026amp; words) { unordered_map\u0026lt;string, int\u0026gt; wordCount; for(auto\u0026amp; w : words){ wordCount[w]++; } int wordLen = words[0].size(); int windowSize = words.size()*wordLen; if(s.size() \u0026lt; windowSize){ return {}; } vector\u0026lt;int\u0026gt; ans; unordered_map\u0026lt;string, int\u0026gt; wordCountInWindow; int i, j; for(int first = 0; first \u0026lt; wordLen; first++){ i = j = first; wordCountInWindow = wordCount; while(j \u0026lt; s.size() \u0026amp;\u0026amp; i \u0026lt; s.size()){ for(;j \u0026lt; i + windowSize; j += wordLen){ string word = s.substr(j, wordLen); if(wordCountInWindow.count(word) == 0){ wordCountInWindow = wordCount; i = j + wordLen; j = i; break; } wordCountInWindow[word]--; if(wordCountInWindow[word] \u0026lt; 0){ while(true){ string old_word = s.substr(i, wordLen); wordCountInWindow[old_word]++; i += wordLen; if(old_word == word){ break; } } j += wordLen; break; } } if(j \u0026gt;= i + windowSize){ ans.push_back(i); string old_word = s.substr(i, wordLen); wordCountInWindow[old_word]++; i += wordLen; } } } return ans; } }; 289.生命游戏 # https://leetcode.cn/problems/game-of-life\n根据 百度百科 ， 生命游戏 ，简称为 生命 ，是英国数学家约翰·何顿·康威在 1970 年发明的细胞自动机。\n给定一个包含 m × n 个格子的面板，每一个格子都可以看成是一个细胞。每个细胞都具有一个初始状态： 1 即为 活细胞 （live），或 0 即为 死细胞 （dead）。每个细胞与其八个相邻位置（水平，垂直，对角线）的细胞都遵循以下四条生存定律：\n如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡； 如果活细胞周围八个位置有两个或三个活细胞，则该位置活细胞仍然存活； 如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡； 如果死细胞周围正好有三个活细胞，则该位置死细胞复活； 下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。\n进阶：\n你可以使用原地算法解决本题吗？请注意，面板上所有格子需要同时被更新：你不能先更新某些格子，然后使用它们的更新后的值再更新其他格子。 本题中，我们使用二维数组来表示面板。原则上，面板是无限的，但当活细胞侵占了面板边界时会造成问题。你将如何解决这些问题？ 题解\n题目本身比较简单，如果需要使用使用原地数组的方式，则需要引入额外的状态标记已改变的状态。（即通过该状态可以推测出原来的状态，也可以推测出新状态）。\n这里我使用-1表示0 -\u0026gt; 1， -2: 1 -\u0026gt; 0。\n代码如下：\nclass Solution { public: void gameOfLife(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; board) { int row, col; row = board.size(); col = board[0].size(); for (int i = 0; i \u0026lt; row; i++) { for (int j = 0; j \u0026lt; col; j++) { int num = cellNum(board, i, j); if (board[i][j] == 1) { if (num \u0026lt; 2 || num \u0026gt; 3) { board[i][j] = -2; } } else if (num == 3) { board[i][j] = -1; } // printf(\u0026#34;(%d, %d) %d, \u0026#34;, i, j, num); } // printf(\u0026#34;\\n\u0026#34;); } for (int i = 0; i \u0026lt; row; i++) { for (int j = 0; j \u0026lt; col; j++) { if (board[i][j] == -1) { board[i][j] = 1; } else if (board[i][j] == -2) { board[i][j] = 0; } } } } static inline int cellNum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; board, int center_i, int center_j) { int now_i, now_j, row, col; row = board.size(); col = board[0].size(); int ans = 0; for (int i = 0; i \u0026lt; 3; i++) { for (int j = 0; j \u0026lt; 3; j++) { if (i == 1 \u0026amp;\u0026amp; i == j) { continue; } now_i = center_i - 1 + i; now_j = center_j - 1 + j; if (now_i \u0026lt; 0 || now_j \u0026lt; 0 || now_i \u0026gt;= row || now_j \u0026gt;= col) { continue; } int tmp = board[now_i][now_j]; if (tmp \u0026lt; 0) { tmp = tmp == -2 ? 1 : 0; } ans += tmp; } } return ans; } }; 205. 同构字符串 # 给定两个字符串 s 和 t ，判断它们是否是同构的。\n如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。\n每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。\n题解\nclass Solution { public: bool isIsomorphic(string s, string t) { unordered_map\u0026lt;char, char\u0026gt; replace_map; unordered_set\u0026lt;char\u0026gt; used_chars; for (int i = 0; i \u0026lt; s.size(); i++) { if (replace_map.count(s[i]) == 0) { if(used_chars.count(t[i])) return false; replace_map[s[i]] = t[i]; used_chars.insert(t[i]); continue; } if (replace_map[s[i]] != t[i]) return false; } return true; } }; 其他没啥，有个小语法问题:\nint a[26] {0}; // 则全初始化为0 int a[26] {1}; // 只有第一个元素为1，其他为0 538. 把二叉搜索树转换为累加树 # https://leetcode.cn/problems/convert-bst-to-greater-tree/\n给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。\n提醒一下，二叉搜索树满足下列约束条件：\n节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同\n题目\n最简单的做法就是反序中序遍历，代码如下所示：\nclass Solution { public: TreeNode* convertBST(TreeNode* root) { treeSum(root, 0); return root; } int treeSum(TreeNode* root, int father_sum){ if(!root){ return 0; } int ans = root-\u0026gt;val; root-\u0026gt;val += father_sum; int right_sum = treeSum(root-\u0026gt;right, father_sum); ans += right_sum; root-\u0026gt;val += right_sum; return ans + treeSum(root-\u0026gt;left, root-\u0026gt;val); } }; 这里把father_sum变成一个全局变量，可能还要更方便一点。\n有一点需要注意，当在计算类似图中节点2时，其的和除了自己，自己左子树的和，还有节点4（根）的和。\n除此之外，官方题解中还提到了Morris遍历，即借用类似线索二叉树遍历的方式（用最左节点的空指针），避免使用额外的空间，空间复杂度只需O(1)。\n这里附上代码：\nclass Solution { public: TreeNode* getSuccessor(TreeNode* node) { TreeNode* succ = node-\u0026gt;right; while (succ-\u0026gt;left != nullptr \u0026amp;\u0026amp; succ-\u0026gt;left != node) { succ = succ-\u0026gt;left; } return succ; } TreeNode* convertBST(TreeNode* root) { int sum = 0; TreeNode* node = root; while (node != nullptr) { if (node-\u0026gt;right == nullptr) { sum += node-\u0026gt;val; node-\u0026gt;val = sum; node = node-\u0026gt;left; } else { TreeNode* succ = getSuccessor(node); if (succ-\u0026gt;left == nullptr) { succ-\u0026gt;left = node; node = node-\u0026gt;right; } else { succ-\u0026gt;left = nullptr; sum += node-\u0026gt;val; node-\u0026gt;val = sum; node = node-\u0026gt;left; } } } return root; } }; 543.二叉树的直径 # 给你一棵二叉树的根节点，返回该树的 直径 。\n二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。\n两节点之间路径的 长度 由它们之间边数表示。\n题解\n考虑每个节点，假设最长直径就是以它为转折，那么此时该路径长度为，左子树的高度加上右子树的高度。\n总有一种方案是最优的，所以比较所有节点的值，取最大的即可。\nclass Solution { public: int ans = 0; int diameterOfBinaryTree(TreeNode* root) { treeHeight(root); return ans; } int treeHeight(TreeNode* root){ if(!root) return -1; int left_h = treeHeight(root-\u0026gt;left); int right_h = treeHeight(root-\u0026gt;right); ans = max(ans, left_h + right_h + 2); return 1 + max(left_h, right_h); } }; ","date":"2 March 2024","permalink":"/posts/algorithms-and-data-structures/lc-problems/","section":"Blogs","summary":"随机做的leetcode题目","title":"Leetcode Problems"},{"content":"","date":"2 March 2024","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"10 January 2024","permalink":"/tags/algorithm/","section":"Tags","summary":"","title":"Algorithm"},{"content":"","date":"10 January 2024","permalink":"/tags/dp/","section":"Tags","summary":"","title":"Dp"},{"content":"","date":"10 January 2024","permalink":"/tags/ds/","section":"Tags","summary":"","title":"Ds"},{"content":" leetcode动态规划 # || 理论 # 具有重叠子问题，明确子问题含义 写出递归方程（状态转移方程） 使用簿记变量以及确定初始化值 很熟悉了不再赘述\n|| leetcode题目 # 509.斐波那契数 # https://leetcode.cn/problems/fibonacci-number/\n斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：\nF(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n \u0026gt; 1 给定 n ，请计算 F(n) 。\n题解：\n没什么好解的，用两个变量递推就是了。\nclass Solution { public: int fib(int n) { int f1 = 1, f2 = 0; if(n == 0 || n == 1) return n; for(int i = 2; i \u0026lt;= n; i++){ f2 = f1 + f2; std::swap(f1, f2); } return f1; } }; 官方题解里还有两个有趣的解法，这里简单说说：\n直接写出齐次线性方程通解 矩阵快速幂，就是写出矩阵递归形式，完了求$M^n$，就是个简单2分n的快速幂求乘法。 70.爬梯子 # https://leetcode.cn/problems/climbing-stairs/\n假设你正在爬楼梯。需要 n 阶你才能到达楼顶。\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n题解：\n状态方程可写为：\n$$ dp[n] = dp[n-1] + dp[n-2] $$\n$dp[n]$表示高为$n$的阶梯有多少种走法。\n和上一题斐波那契数列完全相同，只是初始值不同，这里直接用上一题的代码改一改。\nclass Solution { public: int climbStairs(int n) { int f1 = 1, f2 = 1; if(n == 1) return n; for(int i = 2; i \u0026lt;= n; i++){ f2 = f1 + f2; std::swap(f1, f2); } return f1; } }; 746. 使用最小花费爬楼梯 # https://leetcode.cn/problems/min-cost-climbing-stairs/\n给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。\n你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。\n请你计算并返回达到楼梯顶部的最低花费。\n题解\n看似和上两题有点类似，但子问题含义完全不一样\n设$dp[s]$为s阶楼梯的最小花费，状态转移方程为：\n$$ dp[s] = min \\begin{cases} dp[s-1] + cost[s-1],\\ dp[s-2] + cost[s-2] \\end{cases} \\ dp[0] = 0, dp[1] = 0 $$\n需要注意初始值，由于可以从下标0或1直接开始，所以初始值为0\nclass Solution { public: int minCostClimbingStairs(vector\u0026lt;int\u0026gt;\u0026amp; cost) { // -1, -2 int dp1 = 0, dp2 = 0; for(int i = 2; i \u0026lt;= cost.size(); i++){ dp2 = std::min(dp1 + cost[i - 1], dp2 + cost[i - 2]); std::swap(dp1, dp2); } return dp1; } }; 62. 不同路径 # https://leetcode.cn/problems/unique-paths/\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。\n问总共有多少条不同的路径？\n题解\n首先想到的是动规，再加上滚动数组优化，代码如下：\nclass Solution { public: int uniquePaths(int m, int n) { std::vector\u0026lt;int\u0026gt; dp(m, 1); for(int i = 0; i \u0026lt; n - 1; i++){ for(int j = 1; j \u0026lt; m; j++){ dp[j] += dp[j-1]; } } return dp[m-1]; } }; 不用滚动数组，最原始的dp[i][j]的含义为，从(i, j)出发走到终点有多少条路径。状态转移方程太简单不在赘述。\n官方题解中还有一种使用组合数学的方法，走到终点一定要m+n-2步，而向下一定要走m-1步，当我们确定了m+n-2中何时向下走的m-1步， 剩下的n-1步自然就是向右走的。\n所以问题变为了从m+n-2中选择m-1个数，求$C_{m+n-2}^{m-1}$\n求组合数注意溢出\n63. 不同路径 II # https://leetcode.cn/problems/unique-paths-ii/\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。\n现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？\n网格中的障碍物和空位置分别用 1 和 0 来表示。\n题解\n这题和上一题思路一致，动规加滚动数组优化。\n但需要注意两点：\n有障碍物的地方dp[i][j]可以置为0，不影响状态转移方程（反正都是左+右，为0正好对应走不通）\n初始值，对于最后一行，只有存在一个障碍物，那么障碍物之前的dp的值也为0，因为现在只向右边走，走不通了\n代码如下：\nclass Solution { public: int uniquePathsWithObstacles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; obstacleGrid) { int m = obstacleGrid.size(), n = obstacleGrid[0].size(); std::vector\u0026lt;int\u0026gt; dp(n, 1); int i; for(i = n-1; i \u0026gt;=0; i--){ if(obstacleGrid[m - 1][i] == 1){ break; } } while(i \u0026gt;= 0){ dp[i] = 0; i--; } for(int i = m - 2; i \u0026gt;=0 ; i--){ if(obstacleGrid[i][n - 1] == 1){ dp[n - 1] = 0; } for(int j = n - 2; j \u0026gt;= 0; j--){ if(obstacleGrid[i][j] == 1){ dp[j] = 0; }else{ dp[j] += dp[j + 1]; } } } return dp[0]; } }; 上一题是用的列dp，这里由于obstacleGrid是行主序的，这里改成了行dp最大化利用cache。\n另外第一次提交int溢出了改成long long通过\n343. 整数拆分 # https://leetcode.cn/problems/integer-break/\n给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k \u0026gt;= 2 ），并使这些整数的乘积最大化。\n返回 你可以获得的最大乘积 。\n题解\n最开始的做法搞复杂了，设dp[k][n]表示n拆为k个数时最大乘积。\n状态转移方程为：\n$$ dp[k][n] = max_{1\u0026lt;=i\u0026lt;=n-k+1}(i*dp[k-1][n-i]) $$\n其初始值和遍历顺序见代码：\n#define INX(x, y) (x)*(n+1) + (y) class Solution { public: int integerBreak(int n) { int* dp = new int[(n+1)*(n+1)]; int ret = 1; // initializing for(int i = 2; i \u0026lt;= n; i++){ dp[INX(2, i)] = (i / 2) * (i - i / 2); if(dp[INX(2, i)] \u0026gt; ret) ret = dp[INX(2, i)]; } for(int i = 3; i \u0026lt;= n; i++){ for(int j = 3; j \u0026lt;= n; j++){ int tmp_max = 1, tmp; for(int k = 1; k \u0026lt;= j - i + 1; k++){ tmp = dp[INX(i-1, j-k)] * k; if(tmp \u0026gt; tmp_max) tmp_max = tmp; } dp[INX(i, j)] = tmp_max; if(tmp_max \u0026gt; ret) ret = tmp_max; } } return ret; } }; 如果说这题要求k的个数到也勉强说的过去。\n其实可能多个不同的k的乘积一样大，所以这里没有要求k\n再说标准的做法，设dp[n]为至少拆成2个数时的最大乘积。\n状态转移方程为：\n$$ dp[n] = j*max_{1\u0026lt;=j\u0026lt;n}(i-j, dp[i-j]) $$\n之所以有个i-j是dp[k]含义为至少拆成2，所以j*dp[i-j]表示至少拆成3个数，没有考虑拆成两个的情况，所以这里有个j*(i-j)\nclass Solution { public: int integerBreak(int n) { vector \u0026lt;int\u0026gt; dp(n + 1); for (int i = 2; i \u0026lt;= n; i++) { int curMax = 0; for (int j = 1; j \u0026lt; i; j++) { curMax = max(curMax, max(j * (i - j), j * dp[i - j])); } dp[i] = curMax; } return dp[n]; } }; 最后这里其实有一种巧妙的解法，如果拆成的乘积中存在因数$f\u0026gt;=4$，那么f总能被拆为2*(f-2) 因为$2f-4\u0026gt;=4$，所以最大乘积中一定只能被拆为1、2、3的组合，而如果存在1又总能被加到2或者3上重新拆，所以最后结果只需要2、3就能组合成。\n但其实最终结果中2的次数不会多于两次，因为$222 \u0026lt; 3*3$。\n所以可能的最大乘积的组合一定只会是以下3种可能：\n$333\u0026hellip;*3$ $233*3\u0026hellip;*3$ $22333\u0026hellip;*3$ 并且这三种可能是不能相互转换的，$3^k = 2*3^m$ =\u0026gt; $3^{k-m}=2$显然不成立，另一个等式同理。\n所以，只要求出其中一种可能就只能是这种，不可能是其他两种。而恰好直接除3，根据余数情况可以分别得出这三种情况：\nclass Solution { public: int integerBreak(int n) { if(n \u0026lt;= 3) return (n/2) * (n - n/2); int r = n % 3, p = n / 3; if(r == 0) return pow(3, p); if(r == 1) return 4 * pow(3, p - 1); return 2 * pow(3, p); } }; 96.不同的二叉搜索树 # https://leetcode.cn/problems/unique-binary-search-trees/\n给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的二叉搜索树有多少种？返回满足题意的二叉搜索树的种数。\n题解：\n需要观察到题中为二叉排序树数量。如此一来根据排序树的性质（左子树所有值小于root，右子树所有值大于root，且左右子树也是排序树），就很容易发现子问题了。\n设dp[k]为当n=k时，二叉排序树的数量，其状态转移方式如下：\n$$ dp[k] = \\sum_{i=1}^{k}dp[i-i]*dp[k-i] \\ dp[0] = 1, dp[1] = 1 $$\n通俗来说，当有n个节点时，可以设根节点为k由于节点的值是1~n，所以按照排序树的性质，左子树的值一定是小于k的，右子树一定是大于k\n所以左子树变为了有k-1的节点时，有多少种排序树（这就是子问题了）。知道知道左右子树相乘极为根为k的情况，把k从1~n遍历一遍相加就得到答案了。\nclass Solution { public: int numTrees(int n) { std::vector\u0026lt;int\u0026gt; dp(n+1, 1); for(int k = 2; k \u0026lt;= n; k++){ dp[k] = 0; for(int i = 1; i \u0026lt;= k; i++){ dp[k] += dp[i-1] * dp[k-i]; } } return dp.back(); } }; 这道题比较有意思的是它的数学解法，其实就是卡特兰数（这里的递归推道出来的，没有去证明了）。\n我想说的是，关于n个数字按顺序入栈有多少种出栈顺序，虽然知道结果是卡特兰数但一直不知道怎么来的。那么这里这种递归（动态规划）可以认为是一种做法。和这里一样，但root根就是以某个数出栈来算了(前面的是出栈顺序和后面的出栈顺序)。\n416. 分割等和子集 # https://leetcode.cn/problems/partition-equal-subset-sum/\n给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。\n题解\n必须要先转化一下题目，首先如果可以分解为两个相等的子集，则sum(nums)必须可以整除2才能划分。\n如果能够被整除，设target = sum(nums)/2，并且现在问题转化为了能否从集合中找到和为target的子集，这变成经典的01背包问题了。\n我最初的想法如下，设dp[i][t]为从0-i集合中能否（true or false）找到和为t的子集，转移方程如下：\n$$ dp[i][t] = \\begin{cases} dp[i-1][t], t \u0026lt; nums[i]\\ dp[i-1][t- nums[i]] + nums[i], t \u0026gt;= nums[i] \\ \\end{cases} $$\n并且考虑到target可能很大就没有去用完整的数组，以及自下而上的方式，而是自上而下的。代码如下：\nclass Solution { public: std::vector\u0026lt;std::unordered_map\u0026lt;int, bool\u0026gt;\u0026gt; dp; bool canPartition(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int sum = 0; for (auto num : nums) sum += num; if (sum % 2 != 0) return 0; int target = sum / 2; dp.resize(nums.size()); return _recur(nums, nums.size() - 1, target); } bool _recur(vector\u0026lt;int\u0026gt; \u0026amp;nums, int idx, int target) { if(target \u0026lt; 0) return false; auto\u0026amp; memo = dp[idx]; if(memo.count(target) \u0026gt; 0) return memo[target]; if(idx == 0){ memo[target] = nums[idx] == target; }else memo[target] = _recur(nums, idx - 1, target - nums[idx]) || _recur(nums, idx - 1, target); return memo[target]; } }; 过倒是能过就是慢了一点。\n其实这里1 \u0026lt;= nums[i] \u0026lt;= 100，不算大还是使用常规的自下而上，再加上滚动数组优化好了。\n这里稍微有点不一样，dp[i][t]是按照背包的思维，为此时能放的最大值，最后再来判断是否和target相等。\n其实用我上面的bool也是一样的，懒得去改了\nclass Solution { public: bool canPartition(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int sum = 0; for (auto num : nums) sum += num; if (sum % 2 != 0) return 0; int target = sum / 2; int n = nums.size(); vector\u0026lt;int\u0026gt; dp(target+1, 0); for(int i = 1; i \u0026lt;= n; i++){ for(int t = target; t \u0026gt;= 0 ; t--){ if(t \u0026gt;= nums[i-1]) dp[t] = max(dp[t], dp[t-nums[i-1]] + nums[i-1]); } } return dp[target] == target; } }; 1049. 最后一块石头的重量 II # https://leetcode.cn/problems/last-stone-weight-ii/\n有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。\n每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x \u0026lt;= y。那么粉碎的可能结果如下：\n如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。\n题解\n这道题麻烦在要对题目做个转化，说白了就是要把石头分成两堆，然后其对撞粉碎，差值最小。\n分成两堆差值要最小，要么可以平分，不能平分那么一定一堆比一半大，一堆比一半小。\n所以变为了背包问题，设target = sum(nums) / 2，从所有石头中选择出不超过target的最大值。\n几乎和上一题分割子集合一样。\nclass Solution { public: int lastStoneWeightII(vector\u0026lt;int\u0026gt;\u0026amp; stones) { int sum = 0; for(auto w : stones) sum += w; int target = sum / 2; std::vector\u0026lt;int\u0026gt; dp(target + 1, 0); for(int i = 1; i \u0026lt;= stones.size(); i++){ for(int t = target; t \u0026gt;= stones[i - 1]; t--){ dp[t] = max(dp[t], dp[t - stones[i - 1]] + stones[i - 1]); } } return sum - dp[target] - dp[target]; } }; 494. 目标和 # https://leetcode.cn/problems/target-sum\n给你一个非负整数数组 nums 和一个整数 target 。\n向数组中的每个整数前添加 \u0026lsquo;+\u0026rsquo; 或 \u0026lsquo;-\u0026rsquo; ，然后串联起所有整数，可以构造一个 表达式 ：\n例如，nums = [2, 1] ，可以在 2 之前添加 \u0026lsquo;+\u0026rsquo; ，在 1 之前添加 \u0026lsquo;-\u0026rsquo; ，然后串联起来得到表达式 \u0026ldquo;+2-1\u0026rdquo; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。\n题解\n首先这题很容易想到如下的动态规划，设dp[i][t]为从前i个数（包含[0~i]）中结果为t的数量。\n状态转移方程为：\n$$ dp[i][t] = dp[i-1][t-v] + dp[i-1][t+v] $$\n初始条件见代码，这里没有写\n由于这里不能使用滚动优化，而且自下而上的话也不好确定数组长度，所以这里自上而下。\nclass Solution { public: vector\u0026lt;unordered_map\u0026lt;int, int\u0026gt;\u0026gt; dp; int findTargetSumWays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { dp.resize(nums.size()); return _recur(nums, nums.size() - 1, target); } int _recur(vector\u0026lt;int\u0026gt;\u0026amp; nums, int index, int target) { if(index \u0026lt; 0) return 0; auto\u0026amp; memo = dp[index]; if(memo.count(target)) return memo[target]; if(index == 0){ memo[target] = nums[index] == abs(target) ? 1 : 0; // 都为0时，正负号均可 if(target == 0 \u0026amp;\u0026amp; nums[index] == 0) memo[target] = 2; }else{ memo[target] = _recur(nums, index - 1, target - nums[index]) + _recur(nums, index - 1, target + nums[index]); } return memo[target]; } }; 需要注意初始条件，当nums[0]为0时，正负号均可，所以初始为2。\n看了其他的题解，发现又可以转换为背包问题，其实划分为两个子集（全正的和全负的），设全正的和为x则有\n$$ x - (sum - x) = target \\ x = (target + sum) / 2 $$\n由此可知target + sum一定要整除2，不然不可能。\n所以现在问题变为了从其中选择和为x的子集有多少种。故设dp[i][t]为和为t的种数，状态转移方程为：\n这里i为0~(n-1)\n$$ dp[i][t] = dp[i-1][t] + dp[i-1][t-nums[i]] $$\n初始化见代码\nclass Solution { public: int findTargetSumWays(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int sum = 0; for (auto num : nums){ sum += num; } if(abs(target) \u0026gt; sum || (target + sum) %2 != 0) return 0; int x = (target + sum) / 2; vector\u0026lt;int\u0026gt; dp(x + 1, 0); dp[0] = 1; for(int i = 0; i \u0026lt; nums.size(); i++) { for(int t = x; t \u0026gt;= nums[i]; t--) { dp[t] += dp[t - nums[i]]; } } return dp[x]; } }; 必须注意这里的初始情况，非常不好理解。这里设dp[0]=1其实代表的含义应该是dp[-1][0] = 1就是一个都没有时，为0仍然算一种。\n比如如果数组为[0, 1], target =1，那么其实有两种1和0, 1，所以必须要算前面这种不选的情况，然后递推自动累加。\n474.一和零 # https://leetcode.cn/problems/ones-and-zeroes/\n给你一个二进制字符串数组 strs 和两个整数 m 和 n 。\n请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。\n如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。\n题解\n这题是经典01背包问题，设dp[i][m][n]为题目要的最大子集长度。转移方程就不写了，直接看代码：\nclass Solution { public: int findMaxForm(vector\u0026lt;string\u0026gt;\u0026amp; strs, int m, int n) { #define DP(i, j) dp[(i)*(n+1)+(j)] int* dp = new int[(m+1)*(n+1)]; memset(dp, 0, sizeof(int)*(m+1)*(n+1)); for(int k = 1; k \u0026lt;= strs.size(); k++){ int zeros = 0, ones = 0; for(auto c : strs[k-1]){ if(c == \u0026#39;0\u0026#39;) zeros++; else ones++; } for(int i = m; i \u0026gt;= zeros; i--){ for(int j = n; j \u0026gt;= ones; j--){ DP(i, j) = std::max(DP(i, j), DP(i - zeros, j - ones) + 1); } } } return DP(m, n); } }; [完全背包问题基础] # 完全背包其他和01背包都是一样的，只是现在每个物体有无限个可以拿。\n设dp[i][t]为背包容量为t是从前i个物体中能得到的最大价值和，那么状态转移方程为：\n$$ dp[i][t] = max(dp[i-1][t], dp[i][t-w[i]] + v[i]) $$\n咋一看好像和01背包相同，但注意后一个为dp[i][t-w[i]] + v[i]而不是i-1。\n所以从语义上来说dp[i][t]为要么在最终方案中w[i]一个都不拿，以及拿了一个后，还是从前i个物品(因为还可以拿w[i])中拿时最大的值即dp[i][t-w[i]]\n注意子问题向上推导时的逻辑性，拿了一个之后，如果最终结果中确实包含这么一个，dp[i][t-w[i]] + v[i]确实会更小。如果不包含，那么拿了一个后dp[i][t-w[i]] + v[i]将不会时最优质。\n网上有什么先写出dp[i][t] = max(dp[i-1][t], dp[i-1][t-w[i]] + v[i] +......+ dp[i-1][t-n*w[i]] + n*v[i]) 然后再去推导出这里我写的这个公式，不能说有问题吧。只是做题写递推式还要推导转道弯，确实也太麻烦了\n518. 零钱兑换 II # https://leetcode.cn/problems/coin-change-ii\n给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。\n请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。\n假设每一种面额的硬币有无限个。\n题目数据保证结果符合 32 位带符号整数。\n题解\n同上，就是经典的完全背包问题。代码如下：\nclass Solution { public: int change(int amount, vector\u0026lt;int\u0026gt;\u0026amp; coins) { vector\u0026lt;int\u0026gt; dp(amount + 1, 0); dp[0] = 1; for(int i = 0;i \u0026lt; coins.size(); i++){ for(int j = coins[i]; j \u0026lt;= amount; j++){ dp[j] += dp[j - coins[i]]; } } return dp[amount]; } }; 这里需要注意的是滚动方程优化时的遍历顺序。由于递推方程dp[i][t] = max(dp[i-1][t], dp[i][t-w[i]] + v[i])需要用到上一次的，也需要用到这一次的。\n所以这里必须从前往后遍历，这样dp[t]还是前一次的，但小于t的已经是这一次的值了。\n377. 组合总和 Ⅳ # https://leetcode.cn/problems/combination-sum-iv\n给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。\n题目数据保证答案符合 32 位整数范围。\n示例 1：\n输入：nums = [1,2,3], target = 4 输出：7 解释： 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 示例 2：\n输入：nums = [9], target = 3 输出：0 题解\n注意这个题看似是完全背包问题，但要求排列数而不是组合数。所以其实和背包问题关系不大。\n最开始的想法是设dp[i][t]为末尾是nums[i-1]的排列数量，那么转移方程如下：\n$$ dp[i][t] = \\sum_{k=0}^{n}dp[k][t-nums[i-1]] \\ dp[0][0] = 1 $$\ndp[0][0]表示一个都不选时，target=0数量，应该为1，什么都不选应该认为是一种。\n并且dp[k][t-v]当t刚好等于v时，也代表一种，所以dp[0][0]=1\n代码如下：\nclass Solution { public: int combinationSum4(const vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;int\u0026gt;(target + 1, 0)); dp[0][0] = 1; for(int j = 1; j \u0026lt;= target; j++){ for(int i = 1; i \u0026lt;= n; i++){ if(j \u0026gt;= nums[i - 1]){ for(int k = 0; k \u0026lt;= n; k++){ if(dp[k][j-nums[i-1]] \u0026lt; INT_MAX - dp[i][j]) dp[i][j] += dp[k][j-nums[i - 1]]; } } } } int ret = 0; for(int i = 1; i \u0026lt;= n; i++){ ret += dp[i][target]; } return ret; } }; 此时答案就是以每种数结束的排列数之和。\n关于这里的INT_MAX的使用其实非常牵强，就是dp[i][j] + dp[k][j-nums[i-1]] \u0026lt; INT_MAX，意思是下一次加法会溢出就不求了。但是没有为什么，不这样写就过不了会溢出。(官方题解就是这样写的)\n最开始我改成long long也溢出，还以为想法有问题\n查看官方题解后发现还有改进空间，dp[t]可以直接设为要求的目标，即从nums数组中和为t的排列数。\n官方题解在写什么鬼东西？？？\n然后子问题其实和我的想法是一样的，本质上还是以每个数为结束时的排列数情况。\n$$ dp[t] = \\sum_{k=0}{n-1}dp[t-nums[k]] \\ dp[0] = 1 $$\n这里dp[0]=1就没什么实际含义了，只是dp[t-nums[k]]中t刚好等于nums[k]时应该算一种。\n遍历顺序直接从小到大即可。\n注意这里的dp[t]中t就是target，所以就是普通的dp数组，所以这个遍历顺序没啥。 网上有些题解非要和完全背包扯上关系，说什么求排列就是交换两层for的顺序，求组合就是普通背包的顺序，简直在放屁\nclass Solution { public: int combinationSum4(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int n = nums.size(); vector\u0026lt;int\u0026gt; dp(target + 1, 0); dp[0] = 1; for(int j = 1; j \u0026lt;= target; j++){ for(int i = 1; i \u0026lt;= n; i++){ if(j \u0026gt;= nums[i - 1] \u0026amp;\u0026amp; dp[j-nums[i-1]] \u0026lt; INT_MAX - dp[j]){ dp[j] += dp[j-nums[i - 1]]; } } } return dp[target]; } }; 322. 零钱兑换 # https://leetcode.cn/problems/coin-change\n给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。\n计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。\n你可以认为每种硬币的数量是无限的。\n题解\n标准的完全背包问题，只初始值稍有不同，直接见代码:\nclass Solution { public: int coinChange(std::vector\u0026lt;int\u0026gt;\u0026amp; coins, int amount) { std::vector\u0026lt;int\u0026gt; dp(amount + 1, INT_MAX - 1); dp[0] = 0; for(int i = 1; i \u0026lt;= coins.size(); i++){ for(int j = coins[i-1]; j \u0026lt;= amount; j++) { dp[j] = std::min(dp[j - coins[i-1]] + 1, dp[j]); } } return dp[amount] == INT_MAX - 1 ? -1 : dp[amount]; } }; 这里求最小的值，需要使用INT_MAX作为初始值。\n279.完全平方数 # https://leetcode.cn/problems/perfect-squares\n给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。\n完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。\n题解\n需要对问题做一个转换，可能构成和为n的完全平方数就是，1,2,3....n^(0.5)的每个数的平方，因为这些平方数才是小于n的。\n所以现在和上一题完全一样了，就是在这个数组里找出和为n的最小数量。\nclass Solution { public: int numSquares(int n) { int up = std::sqrt(n); std::vector\u0026lt;int\u0026gt; dp(n + 1, INT_MAX - 1); dp[0] = 0; for(int i = 1;i \u0026lt;= up;i++){ int elem = i * i; for(int j = elem; j \u0026lt;= n; j++){ dp[j] = std::min(dp[j - elem] + 1, dp[j]); } } return dp[n] == INT_MAX - 1 ? 0 : dp[n]; } }; 139. 单词拆分 # https://leetcode.cn/problems/word-break\n给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。\n注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。\n题目\n首先想到的就是回溯法或者说dfs遍历，再加一个记忆变量减枝。这题也确实可以这么做。\n第二个想到的就是把给出的wordDict转换成字典树方便比较。\n这里毕竟是学习动规，所以再考虑动规，dp[i]就是前s[0-i]的字符串是否可以被表示。转移方程就很简单了：\n$$ dp[i] = dp[j] \u0026amp;\u0026amp; s[j+1, i] in wordDict dp[0] = true $$\n其中s[j+1, i]表示一个再wordDict中的单词。\n自底向上填充dp即可，代码如下：\nclass Solution { public: bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { vector\u0026lt;bool\u0026gt; dp(s.size() + 1, false); unordered_set\u0026lt;string\u0026gt; dict; for(auto\u0026amp; w : wordDict) { dict.insert(w); } dp[0] = true; for(int i = 1; i \u0026lt;= s.size(); i++){ for(int j = 0; j \u0026lt; i; j++){ string word = s.substr(j, i - j); if(dict.find(word) != dict.end() \u0026amp;\u0026amp; dp[j]){ dp[i] = true; break; } } } return dp[s.size()]; } };class Solution { public: bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { vector\u0026lt;bool\u0026gt; dp(s.size() + 1, false); unordered_set\u0026lt;string\u0026gt; dict; for(auto\u0026amp; w : wordDict) { dict.insert(w); } dp[0] = true; for(int i = 1; i \u0026lt;= s.size(); i++){ for(int j = 0; j \u0026lt; i; j++){ string word = s.substr(j, i - j); if(dict.find(word) != dict.end() \u0026amp;\u0026amp; dp[j]){ dp[i] = true; break; } } } return dp[s.size()]; } }; 如果使用字典树，内层循环就变成固定的O(n)了。这里内层是O(n^2)，因为substr()还要消耗O(n)\n198. 打家劫舍 # https://leetcode.cn/problems/house-robber\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n题解\n过于简单，见代码：\nclass Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; dp(nums.size() + 1, 0); dp[1] = nums[0]; for(int i = 2; i \u0026lt;= nums.size(); i++) { dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1]); } return dp[nums.size()]; } }; 213.打家劫舍II # https://leetcode.cn/problems/house-robber-ii/\n你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。\n题目\n做这道题之前如果没有做过 198.打家劫舍，可能会感觉无从下手。尽管198非常简单。\n这里由于多了一个限制条件，即头尾相邻，所以没法再用198那种子问题去求解了。\n但是进一步考虑，如果最后一间被偷，那么0和n-2都不能被偷，但此时偷1~n-3就和198是同样的问题了。\n同理如果最后一间不偷，那么0~n-2就变成198同样的问题了。\n直接看代码:\nclass Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums){ return std::max(myrob(nums, 0, nums.size()-2), myrob(nums, 1, nums.size()-3) + nums.back()); } // 198 int myrob(vector\u0026lt;int\u0026gt;\u0026amp; nums, int start, int end){ if(end \u0026lt; start){ return 0; } int ns2 = 0, ns1 = nums[start]; for(int i = start + 1; i \u0026lt;= end; i++){ ns2 = std::max(ns1, ns2 + nums[i]); std::swap(ns1, ns2); } return ns1; } }; 337.打家劫舍 III # https://leetcode.cn/problems/house-robber-iii/\n小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。\n除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。\n给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。\n题解\n比较简单的动态规划，子问题其实就是这里要求的问题。应用是否偷当前节点来组合子问题和值，这里不写转移方程了，直接看代码：\nclass Solution { public: unordered_map\u0026lt;TreeNode*, int\u0026gt; memo; int rob(TreeNode* root) { if(root == nullptr) return 0; if(memo.count(root)) return memo[root]; int not_steal = rob(root-\u0026gt;left) + rob(root-\u0026gt;right); int steal_val = root-\u0026gt;val; if(root-\u0026gt;left) steal_val += rob(root-\u0026gt;left-\u0026gt;left) + rob(root-\u0026gt;left-\u0026gt;right); if(root-\u0026gt;right) steal_val += rob(root-\u0026gt;right-\u0026gt;left) + rob(root-\u0026gt;right-\u0026gt;right); return memo[root] = max(not_steal, steal_val); } }; 这里其实就是深度优先遍历，空间复杂度就是树高，时间复杂度也是O(n)\n但这里对于rob()的调用太多，并且需要使用一个HashMap。可以做如下优化，即直接返回选择当前节点和不选当前节点最优值来组合：\nclass Solution { public: std::pair\u0026lt;int, int\u0026gt; _rob(TreeNode* root){ auto ret = std::make_pair(0, 0); if(root == nullptr){ return ret; } auto l = _rob(root-\u0026gt;left); auto r = _rob(root-\u0026gt;right); ret.first = root-\u0026gt;val + l.second + r.second; // 注意这行，求不选当前节点的最大值时，子节点不一定要选，也可以不选。 ret.second = max(l.first, l.second) + max(r.first, r.second); return ret; } int rob(TreeNode* root) { auto ret = _rob(root); return max(ret.first, ret.second); } }; 647. 回文子串 # https://leetcode.cn/problems/palindromic-substrings/\n给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。\n回文字符串 是正着读和倒过来读一样的字符串。\n子字符串 是字符串中的由连续字符组成的一个序列。\n具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。\n题解\n先看动规的解法，设置dp[i][j]表示字符串s[i:j+1]是否为回文子串，转移方程：\n$$ dp[i][j] = \\begin{cases} dp[i+1][j-1], s[i+1] == j[j-1] \\ false, s[i-1] \\neq j[j-1] \\ \\end{cases} \\ $$\n不好找子问题的时候，去找可能存在的递归关系，然后再考虑是否能再求完改递归后，再转变为自己要求的。\n对于初始值是去了巧的，当计算时，如果i+1 \u0026gt; j-1那么自动为true。\n遍历顺序，把这个二维数组画出来，可以发现求任意[i][j]需要左下角的[i+1][j-1]，所以需要一列一列的遍历。\n在加上滚动数组优化，代码如下：\nclass Solution { public: int countSubstrings(string s){ int n = s.size(); int* dp = new int[n+1]{0}; int count = 0; for(int j = 1; j \u0026lt;= n; j++){ for(int i = 1; i \u0026lt;= j; i++){ if(s[i-1] == s[j-1]){ if(i + 1 \u0026gt; j - 1){ dp[i] = 1; }else{ dp[i] = dp[i+1]; } if(dp[i] == 1) count++; continue; } dp[i] = 0; } } return count; } }; 可以先写s[i-1] != s[j-1]，避免缩进的太厉害\n另外还有个朴素算法，直接遍历每个中心再中心扩散，这里使用\u0026quot;代码随想录\u0026quot;的代码：\nclass Solution { public: int countSubstrings(string s) { int result = 0; for (int i = 0; i \u0026lt; s.size(); i++) { result += extend(s, i, i, s.size()); // 以i为中心 result += extend(s, i, i + 1, s.size()); // 以i和i+1为中心 } return result; } int extend(const string\u0026amp; s, int i, int j, int n) { int res = 0; while (i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n \u0026amp;\u0026amp; s[i] == s[j]) { i--; j++; res++; } return res; } }; 516.最长回文子序列 # https://leetcode.cn/problems/longest-palindromic-subsequence/\n给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。\n子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。\n题解\n设置dp[i][j]为字符串s[i:j+1]中的最大回文子序列的长度，则转移方程如下：\n$$ dp[i][j] = \\begin{cases} dp[i+1][j-1] + 2, s[i-1] == s[j-1] \\ \\max(dp[i+1][j], dp[i][j-1]), s[i-1] \\neq s[j-1] \\ \\end{cases} $$\n先不说初始值和遍历顺序，这个转移方程是需要证明的，远没有那么容易。\n当$s[i-1]\\neqj[j-1]$时，此时s[i]和s[j]不可能同时出现在当前要求的最长回文序列中。所以用max(dp[i+1][j], dp[i][j-1])没有问题。\n当相等时，s[i]和s[j]同时出现再加dp[i+1][j-1]中的最大，此时一定是最大吗？可用反正法证明。\n初始值就是dp[i][i]=1，其他不在上三角的设为0。\n取任意dp[i][j]可以看到其依赖dp[i+1][j-1]和dp[i+1][j]和dp[i][j-1]，也就是左边、下边、左下，故按列遍历，并从下到上，此时无法使用滚动数组优化。\nclass Solution { public: int longestPalindromeSubseq(string s){ int n = s.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;int\u0026gt;(n + 1, 0)); int max_str = -1; for(int j = 1; j \u0026lt;= n; j++){ for(int i = j; i \u0026gt;= 1; i--){ if(i == j){ dp[i][j] = 1; }else if(s[i-1] == s[j-1]){ if(i+1 \u0026gt; j-1){ dp[i][j] = 2; }else{ dp[i][j] = dp[i+1][j-1] + 2; } }else{ dp[i][j] = max(dp[i+1][j], dp[i][j-1]); } if(dp[i][j] \u0026gt; max_str) max_str = dp[i][j]; } } return max_str; } }; 5. 最长回文子串 # https://leetcode.cn/problems/longest-palindromic-substring\n给你一个字符串 s，找到 s 中最长的回文子串。\n如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。\n题解\n这其实和647. 回文子串是一样的，再找所有的回文子串的时候，记录最大的回文串即可。\nclass Solution { public: string longestPalindrome(string s){ int n = s.size(); vector\u0026lt;int\u0026gt; dp(n + 1, 0); int start = 0, end = 0; for(int j = 1; j \u0026lt;= n; j++){ for(int i = 1; i \u0026lt;= j; i++){ if(s[i-1] != s[j-1]){ dp[i] = 0; continue; } if(i+1 \u0026gt; j-1){ dp[i] = 1; }else{ dp[i] = dp[i+1]; } if(dp[i] == 1){ if(j - i \u0026gt;= end - start){ start = i; end = j; } } } } return s.substr(start-1, end-start+1); } }; 121. 买卖股票的最佳时机 # https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/\n给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。\n你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。\n题解\n从左开始通过局部最小值计算。\n先设最左边为最小值设其下标为i，在遇到下一个更小值(设为j)之前，都比他大。\n所以在i到j之间（不包括j）可以计算出此时的最大利润。(这在下文中被称为一块)\n当将i更新为j后，同理又可以计算下一块局部最大利润。\n但为什么，只需要比较每个块的最大利润就可以确定全局的最大利润呢？可用反证法。\n设存在一个更大利润，是跨了这里的块的，设左边买入索引为k右边的为s。\n由上述性质可知（绿色块越来越小），可以证，总有m比k更小，从而利润更大，即块中利润始终比跨块的利润更大。\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int p = 0, max_val = -1, tmp; for(int i = 1; i \u0026lt; prices.size(); i++){ tmp = prices[i] - prices[p]; if(tmp \u0026gt; max_val){ max_val = tmp; } if(prices[i] \u0026lt; prices[p]){ p = i; } } if(max_val \u0026lt; 0) return 0; return max_val; } }; 其次可以使用动态规划去理解，设dp[i]为前i天中的最小价格。那么可以得到，如果一定要第i天卖出时可得的最大利润。\n最优结果一定时某天卖出，所以通过比较就可以得出结果。\n而dp[i] = min(dp[i-1], price[i])，再已知dp[i-1]时，就多了一天，所以直接比较就可知。\n可以求dp[i]和第i天卖出的最大值，以及比较这个值，可以在一个循环中同时进行。\n122. 买卖股票的最佳时机 II # https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii\n给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。\n在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。\n返回 你能获得的 最大 利润 。\n题解\n又是贪心，都要贪心恐惧症了，这证明也太烦人了。\n做法很简单，只需要选择每个\u0026quot;上坡\u0026quot;的最低点买入，最高点卖出，然后累加起来。\n即图中的绿色部分，这里没有考虑两天连续相等的情况（也不需要考虑）。\n反证法，设现在存在一个不是这样买的方案最大，证明矛盾。\n现在从该方案的最后一次买入开始考虑，其可能是两种情况：\n当然这里的第二种情况，这里只是画出了一个例子，通用例子是中间有1个或者多个\u0026quot;尖\u0026quot;，并且最左下可能是下坡，最右上也可能是上坡，这里就没有去画了，因为证明是一样的。\n对于第一种，左边的下到最低，右边的上到最优，这种方案肯定比他大，但也就是我们的上坡方案。\n对于第二种，同样的左边下到最低，右边上到最高的方案也比当前大（想不明白的，可以先左边下到最低时，一定比原方案大，然后再右上，一定有比该方案大）。完了以后，在这个更大方案上，如果不一次买卖，而是拆成多次上坡的买卖一定又更大，因为这些绿色的上坡之间在y轴上有重合，故一定大。\n这样就证明了，这个最后一次买入，一定是小于等于拆成所有买上坡的。\n但这里还有一个问题，如果左边向最小下滑时前次卖出挡住了呢？\n此时可以同时将该前一次卖出下滑，此时整体上反而还是会变大的。最后一次下滑肯定是增大的，而且增大的比前一次减少的还要多。\n好如此一来，可以将最后一次替换成多次买上坡的方案比假设的这个最大的更大，矛盾。\n然后代码就没啥好说的了：\nclass Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int start = 0; int max_profit = 0; prices.push_back(-1); for(int i = 0; i \u0026lt; prices.size() - 1; i++){ if(prices[i + 1] \u0026lt; prices[i]){ max_profit += prices[i] - prices[start]; start = i + 1; } } return max_profit; } }; 这里取了个巧去处理prices最后一段是上坡的情况，prices.push_back(-1)保证最后一定是下降的。\n300. 最长递增子序列 # https://leetcode.cn/problems/longest-increasing-subsequence\n给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。\n子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的 子序列 。\n题解\n第一个解法是经典动态规划：设dp[i]为以s[i]结尾的最长严格递增子序列的长度。\n转移方程为：\n$$ dp[n] = max_{0\u0026lt;=i\u0026lt;=n-1,dp[i]\u0026gt;dp[n]}(dp[i]) + 1 $$\n比较简单，代码如下：\nclass Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; dp(nums.size(), 1); int ret = 1; for(int i = 1;i \u0026lt; nums.size();i++){ for(int j = 0;j \u0026lt; i;j++){ if(nums[i] \u0026gt; nums[j]){ dp[i] = max(dp[i], dp[j] + 1); } } if(dp[i] \u0026gt; ret) ret = dp[i]; } return ret; } }; 但其复杂度为O(n^2)\n第二种解法，通过维护数组d[i]和len的合法性来找。\n这本质上是一种贪心算法，d[i]表示长度为i的所有子序列中末尾最小的那个子序列的末尾，而且显而易见d数组是严格递增的。\n而len则表示d数组的长度。\n所以最开始len = 1, d[1]=nums[0]，这显然是合法的。\n然后从1开始扫描nums数组，并不断维护d和len的合法性，最终len就是结果。\n比如遍历到i时，d和len表示此时0~i-1中子序列的情况，此时如果nums[i] \u0026gt; d[len]则表示可以新增一个更长的子序列len++, d[len]=nums[i]\n如果nums[i] \u0026lt; d[len]，那么没有更长的子序列可以新增，要表示0~i的情况，需要维护d的合理性，则二分去找d中第一个比nums[i]小的。\n236. 二叉树的最近公共祖先 # https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree\n给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。\n百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”\n题解\n这是道经典题了，做法很多，这里我选择后序的深度优先遍历。\n/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { dfs(root, p, q); return ret; } TreeNode* ret = nullptr; int dfs(TreeNode* root, TreeNode* p, TreeNode* q) { if (root == nullptr) { return 0; } if (ret != nullptr) { return 0; } int cnt = 0; cnt = dfs(root-\u0026gt;left, p, q); cnt += dfs(root-\u0026gt;right, p, q); if (root == p || root == q) { cnt++; } if (cnt == 2) { if(ret == nullptr) ret = root; } return cnt; } }; 其实用cnt统计有点多余，直接让dfs左右子树返回是否存在即可判断。\n","date":"10 January 2024","permalink":"/posts/algorithms-and-data-structures/dynamic-planning/dp-leetcode/","section":"Blogs","summary":"leetcode中动态规划相关题目","title":"Leetcode - DP problems"},{"content":" 对齐值确定 # 对齐值为变量的按照某个大小的字节倍数地址对齐\nstruct AlignTest{ char a; double b; } 先说结论：结构的对齐值为最大的成员对齐值，这里也就是按8字节对齐。\n因为如果结构体按照char的1字节对齐，那么由于b始终需要按照8字节对齐，那么将导致a和b之间的padding大小无法确定。\n| a-------b ---a----b 即结构体放的位置不同，将导致a和b之间的padding不同（应为b始终需要对齐）。\n按照最大的对齐值对齐则没有这个问题，比如这里按照8对齐，将导致a始终在8的倍数的地址，从而保证b和a之间的paading一致。\n结构体大小 # 注意，结构体大小受成员的顺序影响。\nstruct A{ int a; double b; char c; } struct B{ double a; int b; char c; } 其中sizeof(A)为24字节，而sizeof(B)为16字节。可见顺序对结构体的影响之大。\n在A和B的内存结构如下：\n[ int a ][ padding 4B ][ double b ][ char c ][ padding 7B ] 首先a是放在一个8对齐的地址上的，所以放b的时候需要4b的对齐，完了放c，但是结构体的对齐为8（考虑数组中，那么结构体必须为8的倍数，因为下一个元素始终要放在8的倍数上），所以需要7b的padding补齐。所以整体大小达到了24B\n[ double a ][ int b ][ char c ][ padding 3B ] 这里同理，但是只需要c后面补齐3b就是8的整体对齐，所以非常紧凑只有16B。所以说严格按照从大到小的顺序的声明成员变量，一定会有最紧凑的内存格式。\n因为整体的对齐值是按照最大的来的，那么第一个放最大的成员，第二个成员同样在最大对齐值上（地址），并且一般成员对齐值都是2的幂次，故大的对齐值一定满足小的对齐值(比如8的倍数一定是4的倍数)，所以一定可以直接放第二个成员，不用padding。\n从大到小排，一定具有最小的填充。\n可反证，如果还有一种更小的填充，那整个结构体一定更小，而结构体本身是要求对齐的。故这个更小的结构体，一定比这个从大到小排列的结构体小对齐值的倍数，但由上有可知，从大到小排列最多只填充对齐值-1，所以如果存在更小的结构体，至少会小对齐值那么多，这比把所有成员直接加一起（也就是这里从大到小排列的方式）还小，根本不可能存放下这个结构体，故矛盾。\n","date":"10 November 2023","permalink":"/posts/c-family/c-struct-align/","section":"Blogs","summary":"C结构体对齐","title":"结构体对齐与结构体大小"},{"content":" 由于初学C++时CXX11标准还未大量使用，大量的新特性断断续续的被学习 但由于以前一些的固有影响，对左右值的理解出现了很大的偏差，故有该篇文章做个梳理\n|| 左右值与左右值引用 # 区分左右值的标准是某个对象是否具有名字：\n// 以下均为左值 int a; const int a; int\u0026amp;\u0026amp; a; int\u0026amp; a; const int\u0026amp; a; const int\u0026amp;\u0026amp; a; // 以下均为右值, 这里单独列出来了，但更多的是在表达式中作为临时对象使用 3 // 以及其他字面常量 func(args); // 返回值为非左值引用 AClass(); 可以看到一个明显的关键在于int\u0026amp;\u0026amp; a是有名字的，他是左值。更深入一点来说，引用的底层就是使用指针实现的，那么对一个临时对象进行了应用，那么就需要一个指针空间来存储该地址，故说是左值问题不大。\n更多的误解就是来自这个有名的右值引用是一个左值\n另一件事是关于重载的:\nvoid test(int\u0026amp;\u0026amp; a); void test(int\u0026amp; a); 编译器具体调用哪个函数，是使用传入参数是左值还是右值来判断的，而不是左值还是右值引用。\n当然一个左值引用无论如何都是一个左值\n故：\nvoid test(int\u0026amp;\u0026amp; a){ std::cout \u0026lt;\u0026lt; \u0026#34;rvalue func\u0026#34; \u0026lt;\u0026lt; std::endl; } void test(int\u0026amp; a){ std::cout \u0026lt;\u0026lt; \u0026#34;lvalue func\u0026#34; \u0026lt;\u0026lt; std::endl; } int\u0026amp;\u0026amp; a = 3; test(a); 其输出的lvalue func。\n如果再加一个重载函数void test(int a);, 那么在使用左值的时候，编译器无法区分具体使用哪个函数\n|| 完美转发 # 这是一个关于使用模板时传递引用参数出现的一个问题。\ntemplate\u0026lt;class T\u0026gt; void wrapper(T\u0026amp;\u0026amp; args){ other_func(args); } 此时args有名字了，那么根据上面所说args将总是左值，即使传入右值，故如果other_func有右值引用版本的重载的话，此时将无法按照预期的调用的右值函数\n要解决这个问题首先要介绍CXX所谓的引用折叠规则。\n一个伪代码说明如下：\nusing lv = int\u0026amp;; using rv = int\u0026amp;\u0026amp;; lv\u0026amp; a; // 仍然为int\u0026amp;类型 lv\u0026amp;\u0026amp; a; // int\u0026amp; rv\u0026amp; a; // int\u0026amp; rv\u0026amp;\u0026amp; a; // int\u0026amp;\u0026amp; 故除了\u0026quot;右值应用的右值应用\u0026quot;这种情况被折叠为右值应用后，其他情况仍然为左值引用。\n有了引用折叠的概念再来看wrapper模板函数，根据传入参数有如下几种情况：\n使用右值调用wrapper，此时是比较符合直觉的，T被推断为int类型。（这里假设一个int型的右值） 使用一个常量左值调用，根据引用折叠，此时只要T被推断为const int\u0026amp;类型，该模板就可以被实例化为一个左值引用函数，符合要求。 使用一个非常量左值调用，同理T被推断为int\u0026amp;即可 如果同时存在T\u0026amp;\u0026amp;和T\u0026amp;两类模板（甚至同时存在T）是，此时不会优先考虑引用折叠，而是先直接匹配。比如，右值就匹配T\u0026amp;\u0026amp;，左值就匹配T\u0026amp; 如果同时存在T类型模板可能会导致编译器不知道匹配哪个出现编译错误（归根结底不是模板匹配的问题，而是函数模板展开称函数后，不知道使用哪个函数的问题） 但注意如果是类模板，同时存在三类是可以的\n所以了解了引用折叠后该如何解决该问题呢？解决方案其实落在了T的推断类型上。\n直接来看C++标准库给出的解决方案：\n// 注意这里不会出现上面的说的编译器不知道匹配哪个的问题，因为其并非是函数而是类模板，直接按对最佳匹配实例化即可 // remove_reference这里将去除T的所有引用,变为非引用的原始类型 template\u0026lt; class T \u0026gt; struct remove_reference { typedef T type; }; template\u0026lt; class T \u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026gt; { typedef T type; }; template\u0026lt; class T \u0026gt; struct remove_reference\u0026lt;T\u0026amp;\u0026amp;\u0026gt; { typedef T type; }; // 该模板用来解决问题 template\u0026lt; class T \u0026gt; T\u0026amp;\u0026amp; forward( typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026amp; t ) noexcept; // 这里解决该问题无需该模板 // 该模板内部用来了static_assert来检查，T是否是左值应用，如果是则出错 // 因为该模板总是被右值t匹配，如果T还是左值，将会导致一个右值转换为左值 template\u0026lt; class T \u0026gt; T\u0026amp;\u0026amp; forward( typename std::remove_reference\u0026lt;T\u0026gt;::type\u0026amp;\u0026amp; t ) noexcept; 修改wrapper函数如下：\ntemplate\u0026lt;class T\u0026gt; void wrapper(T\u0026amp;\u0026amp; args){ other_func(std::forward\u0026lt;T\u0026gt;(args)); } 对应于warpper的输入参数与T的类型推导结果可知：\n使用右值调用wrapper，T被推断为int类型，则forward返回右值 使用一个常量左值调用，T被推断为const int\u0026amp;类型,则forward返回左值 使用一个非常量左值调用，同理T被推断为int\u0026amp;,则forward返回左值 故forward用来保证传递的参数的左右值属性不变。\n其实主要是解决右值传递进来变左值的问题\n","date":"26 February 2023","permalink":"/posts/c-family/cxx-perfect-forward-lr-ref/","section":"Blogs","summary":"c++左右值与完美转发","title":"Cxx完美转发与左右值引用再梳理"},{"content":"","date":"19 June 2022","permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux"},{"content":" shell简介 # shell是unix/linux中最常用的用户接口程序，通过命令行的方式提供给用户访问和修改系统的能力。 shell属于用户态程序，不具有任何特权，甚至可以自己编写一个\u0026rsquo;shell\u0026rsquo;程序。\n常见的shell\nBourne Shell（sh），这是多数UNIX中的标准和默认shell Korn Shell（ksh），这是sh的超集 C Shell（csh），具有c语言风格的shell，完全不同于sh和ksh。属于BSD UNIX的一部分 Bourne Again Shell（bash），bash是基于sh实现的，通常是linux的标准和默认shell Shell基础 # shell是一个标准的c/c++程序，一般位于/bin或者/usr/bin下。用户登录后，自动启动shell。\nshell的基本功能（特征）\n命令执行 文件名替换 I/O重定向 管道 环境控制 后台处理 shell脚本 || Shell命令基本格式 # $ cmd [-opts] [args] shell会忽略多余的不可见字符。 shell中的命令实际有两种，shell的内部命令和可执行文件。可通过type cmd命令查看cmd命令是内建命令还是可执行文件。\n[]表示可选 UNIX中区分大小写，且只接受小写的cmd\n|| I/O重定向 # 在命令的最后使用\u0026lt;、\u0026lt;\u0026lt;、\u0026gt;、\u0026gt;\u0026gt;可实现将标准输出（\u0026gt; file_name）重定向到文件，将文件重定向到标准输入（\u0026lt; file_name)\n\u0026gt;表示输出覆盖，\u0026gt;\u0026gt;表示追加 \u0026lt;\u0026lt; str表示仍然从标准输入读取数据，但当读取到str时结束 重定向的功能非常强大，因为很多程序都提供了从标准输入读取参数数据和将结果输出到标准输出的功能，比如cat、tail、head等等\n在linux中一切的设备其实都是特殊的文件，对于标准输入设备（键盘）和标准输出设备（显示器）也是同理。所以其实标准输入和输出都是打开的文件，通过文件描述符表示。\n描述符 文件 设备 0 stdin 键盘 1 stdout 显示器 2 stderr 显示器 所以上面直接使用\u0026lt;，\u0026gt;其实是对0\u0026lt;，1\u0026gt;的缩写。\nstderr和stdout是分开的，\u0026gt;只会重定向stdout，stderr仍显示在屏幕上不会定向到文件。 可以使用2\u0026gt;\u0026amp;1将stderr也定向到stdout，然后再使用\u0026gt;即可把stderr也定向到文件。因为2\u0026gt;1表示将stderr定向到文件1，所以必须要添加一个\u0026amp;\n|| Shell变量 # shell变量可分为shell标准变量和用户定义变量（局部变量）。标准变量拥有系统可知的名称，用来控制用户的环境信息，所以也叫环境变量（环境变量有一点歧义，统一成为标准变量）。 set命令可列出当前的所有变量，unset命令可删除不需要的变量。 用户可使用var_name=value定义变量，在需要使用变量时，可使用$var_name。 不管给出的value是字符还是数字，都会被看作是字符串。\n变量定义时，等号两边不能有空格。\n使用export var_name可导出变量，此时在所有的子shell进程（多重子shell）中都能访问到该变量。 export命令列出当前的所有导出变量。\n变量替换 # 变量选项 含义 $var 变量的值 ${var} 变量的值。在字符串中使用时，{}可区分出变量名 ${var:-str} 变量不空为变量值，空为str ${var:+str} 和-str相反，var不空为str，空为空 ${var:=str} 和-str类似，var空为str，但会将var设为str ${var:?str} 和-str类似，var空为str，但会直接退出 常见标准变量 # 变量名 含义 HOME 用户主目录，多个命令均使用该变量定位主目录，如无参cd进入主目录 IFS 内部域分隔符，解释为命令行元素分隔符。（bash中实测无效IFS=\u0026quot;:\u0026ldquo;无效，倒是read的确使用IFS分割） PATH shell查找命令（可执行文件）的目录以:分隔。如PATH=:/bin:/，首字符:表示.:当前目录 PS1 命令提示符1，sh中为$。PS1支持特殊字符自动替换，如\\u替换为用户名，\\t为当前时间等。 PS2 未输入完整命令按下Enter后的提示符，默认未\u0026gt; CDPATH cd查找参数的目录，一般未定义CDPATH则在当前目录找 PWD 当前工作目录 SEHLL 当前shell可执行文件的位置 TERM 终端类型 TZ 用户时区 HISTSIZE 历史命令最大数量 TMOUT 用户不输入命令时，超过该时间则自动退出该用户 VISUAL 某些命令使用的编辑器 EDITOR 类似VISUAL，某些命令使用其指定的编辑器 PS1变量支持的特殊字符 # 字符 含义 \\! 命令序号 \\$ 根目录显示#，非根显示$ \\d 当前日期 \\s 当前shell名称 \\t 当前时间 \\u 当前用户名 \\h 主机名 \\W 当前目录 || 元字符 # 元字符既对shell有特殊含义的字符，可以用来实现文件名替换、管道、后台执行、变量引用、命令替换、命令序列等功能。\n文件名替换 # 通过在命令的参数上使用*，?，[]，shell会根据输入参数和元字符自动匹配目录下的文件，并在执行该命令时将参数展开为所有匹配到的文件序列（以空格隔开）。\n字符 功能 ? 匹配任意单个字符 * 匹配任意个字符，可以为0个 [list] 匹配list中任意一个字符，其中list可以采用范围表示如：5-9，a-z等 [!list] 匹配不在list中的任意一个字符 类似正则表达式 不只匹配当前目录，可以给定其他目录的任意字面量前缀如/root/*\n管道 # cmdA|cmdB通过|将cmdA的标准输出连接到cmdB的标准输入。 管道自身其实也是一个特殊的文件。\n执行命令（命令替换） # 在命令前后使用重音符号（反引号）`可以执行包裹的命令，并将命令的标准输出插入到命令所处的位置。如ucount=who|wc -l，ucount将包含当前登录的终端数量。\nbash中$(cmd)同重音符号含义一致\n后台执行 # 在命令末尾添加\u0026amp;，命令将会被shell放在后台执行。也就是说shell会立即返回，重新开始命令提示符。后台执行的程序一般需要重定向输出，以免是屏幕显示混乱。 另外，一般当用户退出系统时，其后台进程也会被中止。可以使用nohup程序执行后台命令，此时将会忽略终端关闭时发出的SIGHUP信号。\nnohup (sleep 10;echo ok) \u0026gt; nohup.out \u0026amp; 如果此时没有执行重定向的文件，则默认定向到nohup.out，毕竟此时连终端都没有了。\nbash中nohup程序并不支持命令序列和命令编组 可以将多条命令写成脚本后执行，nohup sh sh_script \u0026amp;\n命令序列 # 通过;在一行将多个命令隔开，shell会按照顺序从左至右依次执行这些命令。\n命令编组 # 将用;隔开的多条命令用()包裹，可以表现为单条命令，方便多条命令的同时后台执行和重定向。 sleep 10; echo ok\u0026amp;表示的是在前台执行完sleep后再在后台执行echo (sleep 10; echo ok)\u0026amp;表示将整个命令序列都放在后台执行。\n元字符转义 # 可以通过\u0026quot;、'、\\ 对元字符进行转义 \u0026quot;str\u0026quot;，str中除\u0026quot;、$、`外，其他字符均按照字面字符解释 'str'，str中除'外，其他字符均按字符字面含义解释 \\ 后的任意字符按该字符字面意思解释\n$' \\t\\n'在单引号字符串前添加$表示将字符串立即转义，既\\t转为制表符对应的编码而不是两个字符\\和t\n|| 特殊字符 # UNIX支持多种终端，每种终端有自己的功能和特性，有一组特殊的字符代表了这些功能。只需要将这些字符打印到标准输出中（echo或tput）即可控制终端执行该功能。 如字符\\032在vt100终端中表示清屏\n\\0开头表示8进制的字符编码\n系统支持的每一类终端都在终端数据库terminfo中，其是一个文本文件，包含了每个终端对应的功能列表。 任何包含terminfo数据库的系统，都包含一个tput实用程序。 通过tput可以直接打印出某个功能值，tput根据TERM标准变量得知当前终端类型，在结合terminfo即可得知某个功能的值并打印。\n如tput clear可以在任意终端下清屏，而不用管该终端下的具体字符值是多少。 关于终端、控制台、GUI、X11等概念见 blog\n终端功能的简单列表\n参数 功能 bel 响铃 blink 闪烁显示 bold 粗体显示 clear 清屏 cup r c 移动光标到r行c列 dim 显示变暗 ed 从光标位置擦除到底部 el 从光标位置擦除到行尾 smso 启动凸显 rmso 关闭凸显 smul 启动下划线 rmul 关闭下划线 rev 反色显示 sgr 0 关闭所有属性，这是tput blink后关闭闪烁的唯一方式 还可以使用stty程序调整终端参数 stty -echo关闭输入回显（stty echo打开） stty eof \\^D[Ctrl+D]输入eof stty sane恢复默认设置\n|| Shell选项 # bash和ksh等shell提供很多的选项。要打开某个选项执行set -o opt，关闭某个选项set +o opt 如： set -o noclobber禁止用户在重定向时覆盖某个已存在的文件 set -o ignoreeof防止[Ctrl+d]退出当前的登录的shell，[Ctrl+d]本身就表示输入eof set -o vi在交互式shell中命令行编辑采用vi风格\n此时j、k用来切换历史命令 v进入VISUAL或EDITOR定义的编辑器编辑命令行\n|| Shell别名 # alias new_name=cmd命令定义命令的别名。\nalias命令仅在交互式shell中可用 alias命令列出所有的别名\n常用alias\nalias ls=\u0026#34;ls --color=auto\u0026#34; alias echo=\u0026#34;echo -e\u0026#34; alias ll=\u0026#34;ls -l\u0026#34; alias r=\u0026#34;fc -s\u0026#34; # 历史命令 alias rm=trash # 避免误删 trash(){ mv $@ $HOME/.trash/ } || Shell历史命令 # shell会把使用过的命令保存到一个文件中，bash默认保存在主目录的.bash_history中，环境变量HISTSIZE和HISTFILE控制保存的命令数量和文件。\nhistory命令查看历史命令列表\nhistory 10 # 列出最近的10条命令 fc命令可用于列出、编辑、重复执行历史命令\nfc -l # 同history fc -e vim 225 # 先使用vim重新编辑序号为225的命令然后执行 fc -s # 执行最近一条命令 fc -s 225 # 执行225号命令 fc -s vim # 执行最近的以vim开头的一条指令 || Shell配置文件 # sh、ksh、bash中均有两类配置文件，系统配置文件（全局配置）和用户配置文件。 每次启动shell时都会读取系统配置文件，之后再读取当前登录用户主目录下的用户配置文件。\nbash的配置文件读取顺序如下：\n交互式登录时，如直接通过终端输入账号和密码，或使用su - user_name或su -l user_name登录。此时的读取顺序/etc/profile--\u0026gt;/etc/profile.d/*.sh--\u0026gt;~.bash_profile--\u0026gt;~/.bashrc--\u0026gt;/etc/bashrc 非交互式登录时，如使用su USERNAME或图形界面下打开的终端。此时的读取顺序为~.bashrc--\u0026gt;/etc/bashrc--\u0026gt;/etc/profile.d/*.sh Shell编程 # UNIX shell提供一种解释型的命令语言，包含了许多计算机编程语言的一般特性，如顺序、循环、选择等结构。shell的程序文件一般称为shell脚本。\n|| 执行脚本 # 使用sh script_name命令执行\n将shell脚本设为可执行，然后直接使用文件名执行即可\nchmod +x script_name 详见UNIX文件系统操作\n. script_name命令执行\n使用1和2的方式执行，shell都会产生一个shell子进程用于执行脚本 使用3.执行，则直接使用当前的shell执行，不会产生子进程\n|| shell编程基础 # 注释 # shell中使用#作为注释开始，之后到行尾都会认为是注释\n# program 3 date # comment 可以将#!开头的特殊注释放在脚本第一行，指定执行脚本的shell\n#!/bin/bash echo \u0026#34;using bash\u0026#34; 只有在shell脚本作为可执行文件执行直接执行时，才会根据#!选择执行的shell\n变量 # 参见上文**|| Shell变量**节\n可以使用变量保存命令输出 var1=`date` var2=`tput clear` s_bold=`tput smso` e_bold=`tput rmso`\n获取命令行参数 # shell中通过特殊变量获取，shell脚本执行时的命令行参数\n变量名 含义 $0 脚本名，与命令行输入脚本一致 $1,$2\u0026hellip;$9 第1到第9个参数，9个以上的参数将被忽略只能使用$@或$*获取 $# 参数个数 $@ 包含所有的1-9个参数 $* 包含所有的1-9个参数 $? 上一次命令执行的返回值（结果） $$ 执行脚本进程的PID 如果要对位置变量$1-$9赋值可以使用set One Two Three，对其依次赋值\nexit n表示退出当前shell，其中n就是返回值 shell脚本的返回值是最后一条执行指令的返回值，故如果最后为exit n则可指定脚本返回值。\n$@与$*区别在于用双引号括起来时的表现。不括起来含义相同。\nfor arg in \u0026#34;$@\u0026#34; do echo $arg # 将会依次打印每个参数 done for arg in \u0026#34;$*\u0026#34; do echo $arg # 循环只执行一次，一次打印全部参数 done 获取输入 # 使用read指令从输入设备中读取一行。第一个单词赋给第一个变量，第二个单词赋给第二个，如果给出的变量数量不够，则多余的全部赋给最后一个变量，如下。\nread one two rest # 假设输入为 1 2 3 4 5 # 则$one=1 $two=2 $rest=3 4 5 # read自动创建参数同名的变量 IFS变量影响read对单词的划分 即若IFS=:，则输入可为1:2:3:4\n简单函数 # # 定义 [ function ] funname [()] { action; [return int;] } # 像普通命令一样使用 funname 1 2 3 4 5 retrun可返回0-255作为函数的返回值，若无return则已最后一条指令执行结果为返回值。 在函数中使用特殊变量$1-$9 $#获取参数信息\n|| 条件与测试 # 条件结构 # UNIX中每条命令的执行都有返回值，UNIX通过对这个返回值测试提供了条件控制结构。\n若返回值为0则为真此时执行then后的语句块，非0则为假则执行else的。\n# 基础if-then结构 if cmd then commands fi # if-then-else结构 if cmd then true-commands else false-commands fi # if-then-elif结构 if cmd then true-commands elif cmd then commands else commands fi 测试指令 # 除一般sh命令外，shell还提供了专为条件测试使用的test内建命令，test根据参数进行比较后返回0或1。\nshell还提供了true，false的内建命令直接返回0和1\ntest提供了数值比较、字符串比较、文件测试\n数值比较\n比较参数 示例 含义 -eq num1 -eq num2 数值是否相等 -ne num1 -ne num2 是否不等 -gt num1 -gt num2 大于，greater than -ge num1 -ge num2 大于等于 -lt num1 -lt num2 小于 -le num1 -le num2 小于等于 纯数值比较也可以使用let \u0026quot;12\u0026lt;13\u0026quot;指令，此时是把比较表达式看作一个参数，test的则是表达式中所有元素均为参数（也就是均需要空格分隔）\n字符比较\n比较参数 含义 = 字符是否相等 != 是否不等 -n 是否长度非0 -z 是否长度为0 test使用方式是将操作数和比较符号均看作参数，所以=两边需要空格\n文件测试\n示列 含义 -r filename 文件是否存在并可读 -w filename 文件是否存在并可写 -s filename 文件是否存在并且大小非0 -f filename 文件是否存在且是普通文件 -d filename 文件是否存在且是目录 test指令还提供了逻辑参数，可以将多个比较表达式使用逻辑参数组合\n逻辑参数 含义 -a 与 -o 或 ! 非 [ contition ]可简写test condition，如下\n关于[[ condition ]]，[[]]是bash扩展的[]其功能类似，有以下区别 对于[ -z \u0026quot;$b\u0026quot; ] 可以直接使用 [[ -z $b ]]免去双引号 另外就是对于逻辑命令的引入\u0026amp;\u0026amp;和||等，[[ cond1 \u0026amp;\u0026amp; cond2]]，但在其中不可使用-a和-o等。另外\u0026amp;\u0026amp;和||等可直接对任意命令的结果进行逻辑运算\n# 为了避免$val为空导致参数错误，一般需要使用引号将变量括起来 if test \u0026#34;$val\u0026#34; -eq 1 then echo equal fi # []中前后必须要有空格 if [ \u0026#34;$val\u0026#34; -eq 1 ] then echo equal fi || 算数运算 # shell本身并不直接支持算符运算，而是通过命令方式提供，包括expr、let\nexpr # expr的使用方式类似test所有的元素均为参数需要空格隔开\n# expr只支持整数运算 expr 1 + 1 expr 2 - 1 expr 10 / 2 expr 2 \\* 3 expr 10 \\% 3 注意*，%等元字符需要手动转义 在bash中$((exp))形式同样可进行算数运算\nlet # let则是将整个表达式作为参数，且可直接赋值。\n# x为变量，此时无需使用$ let x=x+1 # let \u0026#34;x=x+1\u0026#34; let x=y*2 # let也可用作比较， x、y可为变量也可为整数字面量 let \u0026#34;x\u0026lt;y\u0026#34; 对于let的参数最好用\u0026quot;\u0026quot;包裹，避免元字符带来麻烦\n(( exp ))是let exp的简写\n(( x=x+1 )) (( \u0026#34;x=y*2\u0026#34; )) 同样(( ))中前后均需要空格\n|| 循环结构 # for-in-do-done # for用于遍历序列\nfor varname in list do commands done list是以空格为分隔的序列\nbreak 在循环中可以使用break指令跳出循环，break n表示跳出n重循环。\nwhile-do-done # while则是根据命令的执行结果决定是否执行循环，0则继续执行，非0则终止。\nwhile cmd do commands done cmd可为任意命令，自然也可以使用test、let及其简写\n循环重定向\nwhile read a b c do cmds done \u0026lt; TMP 该重定向对于该循环（无论执行几次）只会打开一次文件，然后再循环中依次读取一行，知道文件尾，read返回非0结束。\nutil-do-done # 基本结构同while，只是util条件与while相反，0则终止，非0继续执行\nutil cmd do commands done || 多路分支结构case # case varname in pattern_1) cmds last-cmd;; # 最后一条指令必须用;;结束 pattern_2) cmd;; *) # 默认分支，必须在最后 cmd;; esac 这里的pattern和前面介绍的文件名替换类似，还可使用|做逻辑组合\ncase $hour in 0?|1[01]) echo \u0026#34;Good Morning\u0026#34;;; 1[2-7]) echo \u0026#34;Good Afternoon\u0026#34;;; *) echo \u0026#34;Good Evening\u0026#34;;; esac || 捕获内核信号 # 内核信号\n编号 名称 含义 1 SIGHUP/挂起 终端断开时发送给该用户的所有进程 2 SIGINT/中断 按下中断建，如Ctrl+D、Ctrl+C 3 SIGQUIT/退出 按下退出键，如Ctrl+]，退出时会进行核心转储 9 SIGKILL/杀死 kill -9发出 15 SIGTERM/终止 kill -15发出 shell使用trap指令捕获信号，设置对于该信号的处理方式。 # 覆盖15信号的默认处理，转而执行echo trap \u0026#34;echo I refuse to die\u0026#34; 15 # 忽略2 3信号 trap \u0026#34;\u0026#34; 2 3 # 2 3信号复位默认处理方式 trap 2 3 || 调试shell程序 # 可以通过带选项的sh执行对脚本的调试\n选项 功能 -n 读取脚本但不执行，只进行语法检测 -v 每执行一条命令，都在stdout中显示原命令 -x 类似-v，但是显示的是变量替换完成后的命令 ","date":"19 June 2022","permalink":"/posts/linux-basis/shell-basis/","section":"Blogs","summary":"shell脚本基础语法（不全）","title":"shell基础"},{"content":" UNIX简介 # UNIX系统最初由贝尔实验室开发，随后发展为商用操作系统。 UNIX主要有两个版本：\nAT\u0026amp;T公司发布的System V 加利福利亚Berkeley分校 UNIX（BSD） 其他的UNIX系统变体基本都基于这个两个版本\n伯克利分校发布4.4BSD2后，BSD就停止发展了。 从这以后一些基于4.4BSD的版本如FreeBSD、OpenBSD仍在发展 AT\u0026amp;T的System V第四版（SVR4）是UNIX标准化的一个结果（系统调用接口）推动了可在所有UNIX上运行的程序的开发，该接口称为SVID（SV Interface Definition）。 而其他UNIX厂商联合相关UNIX产品开发商制定了POSIX（Portable Operating System Interface for Computer Environment）标准。 POSIX很大程度上基于SVID。\n|| 其他UNIX系统 # Linux # Linux不同于UNIX，是一个完全自由发布的UNIX版本。\n由于版权Linux不叫UNIX，但实际上它就是UNIX。Linux遵循很多与UNIX一样的标准\nSolaris # SunOS后称Solaris，最初是Sun公司基于SV2和BSD 4.3开发的。后Solaris2.0基于SVR4开发。\nUnixWare # UnixWare是基于SV系统的，只能用于Intel 处理器的计算机\nUNIX入门 # || UNIX登录过程 # UNIX完成启动后，init进程会为每个终端启动一个getty程序，负责在屏幕显示login:等信息并等待用户输入用户名，getty程序读取用户名后传递给login程序，然后login显示password:字符串并等待用户输入密码，login验证口令正确后则会根据用户定义启动一个shell程序，并进入用户主目录。\ngraph TB A(init进程)--\u0026gt;B(getty) B--\u0026gt;C(login) C--\u0026gt;D(shell) D--\u0026gt;A || UNIX用户 # 用户信息保存在/etc/passwd文件中，每个用户在该文件中用一行表示，每一行由7个用冒号分隔的字段表示。这些字段的含义如下：（按顺序）\nroot❌0:0::/root:/bin/bash login-name password，存储加密口令。SVR4中加密口令单独保存在/etc/shadow，此处使用x做占位符 user-id group-id user-info，用户描述字段 directory，用户主目录 program，指定登录后要运行的程序，一般是一个shell passwd命令可修改当前用户的口令。\n要添加/删除用户可以直接编辑/etc/passwd文件（需要root权限），但一般使用useradd指令更安全。\n|| UNIX简单命令 # 自行使用man或者\u0026ndash;help参数查看帮助\n显示日期与时间：date # 当前登录用户信息：who # 日历：cal # 获取帮助：\u0026ndash;help/man # ","date":"19 June 2022","permalink":"/posts/linux-basis/unix-introduction/","section":"Blogs","summary":"unix系统简介和入门知识","title":"UINIX简介与入门"},{"content":" UNIX文件系统简介 # || 文件系统基本原理 # UNIX文件系统采用索引节点（i节点）的方式实现。目录文件中仅包含文件名和i节点序号等基本信息，而i节点本身才包含文件存储物理位置、权限、时间戳等具体信息。 UNIX的i节点采用混合索引的方式，在缩影节点中包含10个直接地址项、1个一级简介地址项、1个二级简介地址项、1个三级间接地址项。\n|| 文件系统安全 # 每个文件和目录都拥有3组9位访问控制位实现文件保护，分别是拥有者权限位、同组用户权限位、其他用户权限位，每一组都包含rwx3位分别控制该对象是否拥有读、写、执行的权限。 目录文件具有x权限表示可以使用cd进入该目录或使用该目录作为路劲名的一部分。\n使用chmod可改变保护位，见下文 文件还有s权限，具体见sudo权限提升原理文档\n|| 挂载文件系统 # mount [opts] source dir # 卸载文件系统 umount [opts] dir 此时属于临时挂载，需要开机自动挂载需要编辑/etc/fstab文件。 添加一行内容：\n设备 挂载点 文件系统类型 挂载参数 是否备份 是否检测 /dev/sdb1 /mnt/newd linux defaults 0 0 执行mount -a可让文件立即生效。\nUNIX文件 # || UNIX文件简介 # 在UNIX中，文件就是字节序列，文件系统本身不支持带有结构的文件，这些是具体应用程序需要做的。\nUNIX文件类型 # 普通文件 目录文件 特殊文件，如系统中的设备均抽象为文件 隐藏文件 # 文件以.开头的为隐藏文件。 每个目录中都至少包含.当前目录和..上级目录\n|| 文件操作 # 这里只显示最简单的用法和参数，具体使用--help参数或者man命令\n创建\u0026amp;编辑文件 # UNIX中创建文件的方式有多种如下，\ntouch file创建空文件，一般touch用于更新时间戳，故只在文件不存在时创建目录 vim file cat \u0026gt; file，利用重定向和cat创建小文件（见下文） 编辑文件可使用vim、emacs等编辑器 复制/移动/删除文件：cp/mv/rm # cp复制文件\ncp [option]... source dest cp [option]... source... dir 选项 含义 -b 若目标文件已存在，则创建备份 -i 若目标文件已存在，要求确认 -f 文件存在，不提示直接覆盖 -r 递归拷贝所有子目录和子文件 mv移动文件\nmv [option]... source dest mv [option]... source... dir 选项 含义 -b 若目标文件已存在，则创建备份 -i 若目标文件已存在，要求确认 -f 若目标文件存在，不用确认直接覆盖 -r 递归移动所有子目录和子文件 mv命令可用作文件重命名\nrm删除文件\nrm [option]... file... 选项 含义 -i 删除是要求确认 -f 直接删除，忽略不存在文件，不提示 -r 递归删除目录 rm删除的文件不可恢复，需要谨慎使用 替代方案是将rm定义为mv的别名覆盖掉rm，如下\nalias rrm=\u0026#34;/usr/bin/rm\u0026#34; alias srm=trash alias rm=trash trash(){ mv $@ $HOME/.trash/\t} 显示文件：cat/head/tail # cat(concatenate)拼接多个文件 cat拼接多个文件（以及标准输入），并将结果输出到标准输出（所有文件内容）。\ncat [option]... file... 无参cat从标准输入读取输入直到eof（Ctrl+D），输出到标准输出。故可以结合重定向使用cat创建小文件。 另外若要连接文件和标准输入，cat file -其中-表示从标准输入读取。\nhead显示前多少项\nhead [option]... file... 同样-以及无参表示从标准输入中读取。\n选项 含义 -n -n 10即显示前10行，也可用-10替代，-n -10显示全部除了最后10行 -c -c 10显示前10个字节 tail显示后多少项\ntail [option]... file... 同样-以及无参表示从标准输入中读取。\n选项 含义 -n -n 10即显示后10行，也可用-10替代，-n +10表示从第10行开始到文件尾 -c -c 10显示后10个字节 分页显示文件：less/more # less和more指令都可以分页显示文件，特别对于查看大文件方便。 more只能往前查看，不能再倒回去 less可以向前后查看，操作方法类似vim\n链接文件：ln # ln [option]... target link_name 创建名为link_name的对target的硬连接。 -s选项指定创建软连接。\n硬连接则表示再link_name的目录项中直接插入名为linke_name的项，然后设置其i节点序号为target的 软连接则是创建名为link_name的链接文件，然后在该文件中存储traget的目录路径\n按域显示文件：cut # cut -f 1-3 file 表示显示file的第1到3列的内容\n选项 含义 -f 指定显示的域-f 1、-f 1,7、-f 1-7 -c 指定字符位置 -d 指定域分隔符（默认为空格制表符） 按行链接文件：paste # paste [opt]... file... 所有输入的文件的的行，拼接成新行，分隔符通过-d指定默认为制表符。\n文件内容计数：wc # wc -wlc test.c # 12 18 180 test.c 选项 含义 -w 统计单词数量 -c 统计字节数量 -l 统计行数 -m 统计字符数量 修改文件模式：chmod/chown/chgrp # chmod修改文件保护位\nchmod u+x file\t# 拥有者增加执行权限 chmod g+rw file\t# 组增加读写权限 chmod o+w file\t# 其他用户增加写权限 chmod o-r file\t# 其他用户减少读权限 chmod a+w file\t# 全部（三组）都增加写权限 chmod a=rwx file# 全部都设为rwx chmod +s file\t# 增加s权限 # 也可以采用八进制的方式 # 例如 u(rwx) g(r-x) o(r-x) # 即u(111) g(101) o(101) # 即u(7) g(5) o(5) chmod 755 file chown修改拥有者\n# 修改拥有者为root，当然需要root权限 chown root file chgrp修改所属组\n# 修改组为root，当然需要root权限 chgrp root file 查找文件位置：find # find start_dir \u0026lt;opt\u0026gt; 选项 含义 -name filename 根据指定文件名查找，filename可以使用通配符，含义和文件名替换类似，需要使用引号括起来避免被替换。 -size +-n 指定查找文件大小（块），-size +10表示大于10块的，-10表示小于10块的 -type ft 指定查找文件类型，ft可以为b块设备文件、c字符设备文件、d目录文件、f普通文件 -atime +-n 指定访问时间（天），同样可给出+-表示范围 -mtime +-n 指定修改时间（天），同样可给出+-表示范围 -newer filename 比filename更新的文件 -print 找到文件后打印文件路径（默认） -exec cmd ; 找到（每个）文件后执行cmd -ok cmd ; 找到（每个）文件后先询问，再执行cmd 查找文件内容：grep # 该命令在文件中查找指定模式，找到则显示整行。\ngrep [option]... patterns [file]... 同样但不指定文件时从标准输入中读取内容并查找。\n选项 含义 -c 显示每个文件中匹配的行数 -i 匹配时忽略大小写 -l 只显示含有匹配模式的文件名，而不显示具体的匹配行 -n 每个输出行前显示行号 -v 显示与模式不匹配的行 文件归档\u0026amp;压缩 # 压缩和归档是两会事情。 tar指令可将多个文档归档（解开）为一个文件，此时并未进行压缩，只是为压缩提供了条件（因为有些压缩算法只支持对单个文件压缩如gzip）。\ntar为了方便使用也提供了参数，在归档完成后可以立即进行压缩\ntar -cvf archive.tar file1 file2 dir tar -xvf archive.tar -C dest_dir # 对应加解档参数前添加需要的压缩算法参数即可 tar -zcf archive.tar.gz file1 file tar -zxf archive.tar.gz tar部分参数\n选项 含义 -c 创建归档 -f 指定归档文件 -r 增加文件到归档文件 -t 列出归档中的文件 -x 解开归档文件 -v verbose显示详细创建/解档过程 -z 归档后用gzip算法压缩 -j 归档后用bzip2算法压缩 || 文件名替换 # 使用shell元字符*、[]、?替换\n见shell基础\u0026amp;编程文档中元字符一节\n|| shell重定向 # 使用\u0026gt;、\u0026gt;\u0026gt;、\u0026lt;、\u0026lt;\u0026lt;重定向输入输出到文件\n见shell基础\u0026amp;编程文档中I/O重定向一节\nUNIX目录 # || 目录相关概念 # UNIX重要目录 # 目录 说明 / 根目录 /usr 面向用户的目录 /usr/bin/面向用户的可执行文件 /usr/sbin/系统管理文件 /bin 存放基本UNIX程序 /dev 存放设备文件 /sbin 存放系统文件，通常由UNIX自行运行 /etc 存放配置文件 用户主目录 # 每个用户都有一个自己的主目录\n当前工作目录 # shell当前工作的目录，可提供给相对路径使用。 pwdprint work dir可打印当前的工作目录 cd dir切换工作目录到dir\n绝对路径与相对路径 # /开头的为绝对路径。 相对路径是为了用户使用方便以及减少目录的查询时间，即从当前的工作目录开始查找。\n|| 目录操作 # 创建目录：mkdir # mkdir -p /usr/home/xui/new_dir -p参数表示不存在的父目录也一同创建。\n列出目录项：ls # 选项 说明 -a 列出全部，包括隐藏 -C 用多列格式列出，按列排序 -F 目录后加/，可执行文件后加* -l 长格式显示，即显示文件详细信息 -m 按页宽显示，用逗号隔开 -p 目录后加/ -r 字母反序排列 -R 递归列出子目录 -s 以块为单位 -x 以多列格式列出，以行排序 -h 人类可读的单位 删除空目录：rmdir # rmdir dir 若dir不为空需要使用rm删除\n","date":"19 June 2022","permalink":"/posts/linux-basis/unix-file-system-intro/","section":"Blogs","summary":"UNIX文件系统基本原理与简单使用","title":"UNIX文件系统操作"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"}]