[{"content":"UNIX初级教程 - Unix Unbounded: A Beggining Approach\n","date":"3 March 2024","permalink":"/series/unix-unbounded/","section":"Series","summary":"UNIX初级教程 - Unix Unbounded: A Beggining Approach","title":"Unix Unbounded"},{"content":" ","date":"3 March 2024","permalink":"/","section":"Blogs","summary":" ","title":"Blogs"},{"content":" 各种各样的技术相关博客（或许）以及笔记 - Linux、C/C++、GO、Rust、分布式系统、数据库、操作系统\u0026hellip;\u0026hellip; ","date":"3 March 2024","permalink":"/posts/","section":"Blogs","summary":" 各种各样的技术相关博客（或许）以及笔记 - Linux、C/C++、GO、Rust、分布式系统、数据库、操作系统\u0026hellip;\u0026hellip; ","title":"Blogs"},{"content":" 读书笔记和各种成系列的笔记 ","date":"3 March 2024","permalink":"/series/","section":"Series","summary":" 读书笔记和各种成系列的笔记 ","title":"Series"},{"content":" 读书笔记和各种成系列的笔记 ","date":"3 March 2024","permalink":"/topics/","section":"Topics","summary":" 读书笔记和各种成系列的笔记 ","title":"Topics"},{"content":"","date":"19 June 2022","permalink":"/topics/linux-basis/","section":"Topics","summary":"","title":"Linux-Basis"},{"content":" shell简介 # shell是unix/linux中最常用的用户接口程序，通过命令行的方式提供给用户访问和修改系统的能力。 shell属于用户态程序，不具有任何特权，甚至可以自己编写一个\u0026rsquo;shell\u0026rsquo;程序。\n常见的shell\nBourne Shell（sh），这是多数UNIX中的标准和默认shell Korn Shell（ksh），这是sh的超集 C Shell（csh），具有c语言风格的shell，完全不同于sh和ksh。属于BSD UNIX的一部分 Bourne Again Shell（bash），bash是基于sh实现的，通常是linux的标准和默认shell Shell基础 # shell是一个标准的c/c++程序，一般位于/bin或者/usr/bin下。用户登录后，自动启动shell。\nshell的基本功能（特征）\n命令执行 文件名替换 I/O重定向 管道 环境控制 后台处理 shell脚本 || Shell命令基本格式 # $ cmd [-opts] [args] shell会忽略多余的不可见字符。 shell中的命令实际有两种，shell的内部命令和可执行文件。可通过type cmd命令查看cmd命令是内建命令还是可执行文件。\n[]表示可选 UNIX中区分大小写，且只接受小写的cmd\n|| I/O重定向 # 在命令的最后使用\u0026lt;、\u0026lt;\u0026lt;、\u0026gt;、\u0026gt;\u0026gt;可实现将标准输出（\u0026gt; file_name）重定向到文件，将文件重定向到标准输入（\u0026lt; file_name)\n\u0026gt;表示输出覆盖，\u0026gt;\u0026gt;表示追加 \u0026lt;\u0026lt; str表示仍然从标准输入读取数据，但当读取到str时结束 重定向的功能非常强大，因为很多程序都提供了从标准输入读取参数数据和将结果输出到标准输出的功能，比如cat、tail、head等等\n在linux中一切的设备其实都是特殊的文件，对于标准输入设备（键盘）和标准输出设备（显示器）也是同理。所以其实标准输入和输出都是打开的文件，通过文件描述符表示。\n描述符 文件 设备 0 stdin 键盘 1 stdout 显示器 2 stderr 显示器 所以上面直接使用\u0026lt;，\u0026gt;其实是对0\u0026lt;，1\u0026gt;的缩写。\nstderr和stdout是分开的，\u0026gt;只会重定向stdout，stderr仍显示在屏幕上不会定向到文件。 可以使用2\u0026gt;\u0026amp;1将stderr也定向到stdout，然后再使用\u0026gt;即可把stderr也定向到文件。因为2\u0026gt;1表示将stderr定向到文件1，所以必须要添加一个\u0026amp;\n|| Shell变量 # shell变量可分为shell标准变量和用户定义变量（局部变量）。标准变量拥有系统可知的名称，用来控制用户的环境信息，所以也叫环境变量（环境变量有一点歧义，统一成为标准变量）。 set命令可列出当前的所有变量，unset命令可删除不需要的变量。 用户可使用var_name=value定义变量，在需要使用变量时，可使用$var_name。 不管给出的value是字符还是数字，都会被看作是字符串。\n变量定义时，等号两边不能有空格。\n使用export var_name可导出变量，此时在所有的子shell进程（多重子shell）中都能访问到该变量。 export命令列出当前的所有导出变量。\n变量替换 # 变量选项 含义 $var 变量的值 ${var} 变量的值。在字符串中使用时，{}可区分出变量名 ${var:-str} 变量不空为变量值，空为str ${var:+str} 和-str相反，var不空为str，空为空 ${var:=str} 和-str类似，var空为str，但会将var设为str ${var:?str} 和-str类似，var空为str，但会直接退出 常见标准变量 # 变量名 含义 HOME 用户主目录，多个命令均使用该变量定位主目录，如无参cd进入主目录 IFS 内部域分隔符，解释为命令行元素分隔符。（bash中实测无效IFS=\u0026quot;:\u0026ldquo;无效，倒是read的确使用IFS分割） PATH shell查找命令（可执行文件）的目录以:分隔。如PATH=:/bin:/，首字符:表示.:当前目录 PS1 命令提示符1，sh中为$。PS1支持特殊字符自动替换，如\\u替换为用户名，\\t为当前时间等。 PS2 未输入完整命令按下Enter后的提示符，默认未\u0026gt; CDPATH cd查找参数的目录，一般未定义CDPATH则在当前目录找 PWD 当前工作目录 SEHLL 当前shell可执行文件的位置 TERM 终端类型 TZ 用户时区 HISTSIZE 历史命令最大数量 TMOUT 用户不输入命令时，超过该时间则自动退出该用户 VISUAL 某些命令使用的编辑器 EDITOR 类似VISUAL，某些命令使用其指定的编辑器 PS1变量支持的特殊字符 # 字符 含义 \\! 命令序号 \\$ 根目录显示#，非根显示$ \\d 当前日期 \\s 当前shell名称 \\t 当前时间 \\u 当前用户名 \\h 主机名 \\W 当前目录 || 元字符 # 元字符既对shell有特殊含义的字符，可以用来实现文件名替换、管道、后台执行、变量引用、命令替换、命令序列等功能。\n文件名替换 # 通过在命令的参数上使用*，?，[]，shell会根据输入参数和元字符自动匹配目录下的文件，并在执行该命令时将参数展开为所有匹配到的文件序列（以空格隔开）。\n字符 功能 ? 匹配任意单个字符 * 匹配任意个字符，可以为0个 [list] 匹配list中任意一个字符，其中list可以采用范围表示如：5-9，a-z等 [!list] 匹配不在list中的任意一个字符 类似正则表达式 不只匹配当前目录，可以给定其他目录的任意字面量前缀如/root/*\n管道 # cmdA|cmdB通过|将cmdA的标准输出连接到cmdB的标准输入。 管道自身其实也是一个特殊的文件。\n执行命令（命令替换） # 在命令前后使用重音符号（反引号）`可以执行包裹的命令，并将命令的标准输出插入到命令所处的位置。如ucount=who|wc -l，ucount将包含当前登录的终端数量。\nbash中$(cmd)同重音符号含义一致\n后台执行 # 在命令末尾添加\u0026amp;，命令将会被shell放在后台执行。也就是说shell会立即返回，重新开始命令提示符。后台执行的程序一般需要重定向输出，以免是屏幕显示混乱。 另外，一般当用户退出系统时，其后台进程也会被中止。可以使用nohup程序执行后台命令，此时将会忽略终端关闭时发出的SIGHUP信号。\nnohup (sleep 10;echo ok) \u0026gt; nohup.out \u0026amp; 如果此时没有执行重定向的文件，则默认定向到nohup.out，毕竟此时连终端都没有了。\nbash中nohup程序并不支持命令序列和命令编组 可以将多条命令写成脚本后执行，nohup sh sh_script \u0026amp;\n命令序列 # 通过;在一行将多个命令隔开，shell会按照顺序从左至右依次执行这些命令。\n命令编组 # 将用;隔开的多条命令用()包裹，可以表现为单条命令，方便多条命令的同时后台执行和重定向。 sleep 10; echo ok\u0026amp;表示的是在前台执行完sleep后再在后台执行echo (sleep 10; echo ok)\u0026amp;表示将整个命令序列都放在后台执行。\n元字符转义 # 可以通过\u0026quot;、'、\\ 对元字符进行转义 \u0026quot;str\u0026quot;，str中除\u0026quot;、$、`外，其他字符均按照字面字符解释 'str'，str中除'外，其他字符均按字符字面含义解释 \\ 后的任意字符按该字符字面意思解释\n$' \\t\\n'在单引号字符串前添加$表示将字符串立即转义，既\\t转为制表符对应的编码而不是两个字符\\和t\n|| 特殊字符 # UNIX支持多种终端，每种终端有自己的功能和特性，有一组特殊的字符代表了这些功能。只需要将这些字符打印到标准输出中（echo或tput）即可控制终端执行该功能。 如字符\\032在vt100终端中表示清屏\n\\0开头表示8进制的字符编码\n系统支持的每一类终端都在终端数据库terminfo中，其是一个文本文件，包含了每个终端对应的功能列表。 任何包含terminfo数据库的系统，都包含一个tput实用程序。 通过tput可以直接打印出某个功能值，tput根据TERM标准变量得知当前终端类型，在结合terminfo即可得知某个功能的值并打印。\n如tput clear可以在任意终端下清屏，而不用管该终端下的具体字符值是多少。 关于终端、控制台、GUI、X11等概念见 blog\n终端功能的简单列表\n参数 功能 bel 响铃 blink 闪烁显示 bold 粗体显示 clear 清屏 cup r c 移动光标到r行c列 dim 显示变暗 ed 从光标位置擦除到底部 el 从光标位置擦除到行尾 smso 启动凸显 rmso 关闭凸显 smul 启动下划线 rmul 关闭下划线 rev 反色显示 sgr 0 关闭所有属性，这是tput blink后关闭闪烁的唯一方式 还可以使用stty程序调整终端参数 stty -echo关闭输入回显（stty echo打开） stty eof \\^D[Ctrl+D]输入eof stty sane恢复默认设置\n|| Shell选项 # bash和ksh等shell提供很多的选项。要打开某个选项执行set -o opt，关闭某个选项set +o opt 如： set -o noclobber禁止用户在重定向时覆盖某个已存在的文件 set -o ignoreeof防止[Ctrl+d]退出当前的登录的shell，[Ctrl+d]本身就表示输入eof set -o vi在交互式shell中命令行编辑采用vi风格\n此时j、k用来切换历史命令 v进入VISUAL或EDITOR定义的编辑器编辑命令行\n|| Shell别名 # alias new_name=cmd命令定义命令的别名。\nalias命令仅在交互式shell中可用 alias命令列出所有的别名\n常用alias\nalias ls=\u0026#34;ls --color=auto\u0026#34; alias echo=\u0026#34;echo -e\u0026#34; alias ll=\u0026#34;ls -l\u0026#34; alias r=\u0026#34;fc -s\u0026#34; # 历史命令 alias rm=trash # 避免误删 trash(){ mv $@ $HOME/.trash/ } || Shell历史命令 # shell会把使用过的命令保存到一个文件中，bash默认保存在主目录的.bash_history中，环境变量HISTSIZE和HISTFILE控制保存的命令数量和文件。\nhistory命令查看历史命令列表\nhistory 10 # 列出最近的10条命令 fc命令可用于列出、编辑、重复执行历史命令\nfc -l # 同history fc -e vim 225 # 先使用vim重新编辑序号为225的命令然后执行 fc -s # 执行最近一条命令 fc -s 225 # 执行225号命令 fc -s vim # 执行最近的以vim开头的一条指令 || Shell配置文件 # sh、ksh、bash中均有两类配置文件，系统配置文件（全局配置）和用户配置文件。 每次启动shell时都会读取系统配置文件，之后再读取当前登录用户主目录下的用户配置文件。\nbash的配置文件读取顺序如下：\n交互式登录时，如直接通过终端输入账号和密码，或使用su - user_name或su -l user_name登录。此时的读取顺序/etc/profile--\u0026gt;/etc/profile.d/*.sh--\u0026gt;~.bash_profile--\u0026gt;~/.bashrc--\u0026gt;/etc/bashrc 非交互式登录时，如使用su USERNAME或图形界面下打开的终端。此时的读取顺序为~.bashrc--\u0026gt;/etc/bashrc--\u0026gt;/etc/profile.d/*.sh Shell编程 # UNIX shell提供一种解释型的命令语言，包含了许多计算机编程语言的一般特性，如顺序、循环、选择等结构。shell的程序文件一般称为shell脚本。\n|| 执行脚本 # 使用sh script_name命令执行\n将shell脚本设为可执行，然后直接使用文件名执行即可\nchmod +x script_name 详见UNIX文件系统操作\n. script_name命令执行\n使用1和2的方式执行，shell都会产生一个shell子进程用于执行脚本 使用3.执行，则直接使用当前的shell执行，不会产生子进程\n|| shell编程基础 # 注释 # shell中使用#作为注释开始，之后到行尾都会认为是注释\n# program 3 date # comment 可以将#!开头的特殊注释放在脚本第一行，指定执行脚本的shell\n#!/bin/bash echo \u0026#34;using bash\u0026#34; 只有在shell脚本作为可执行文件执行直接执行时，才会根据#!选择执行的shell\n变量 # 参见上文**|| Shell变量**节\n可以使用变量保存命令输出 var1=`date` var2=`tput clear` s_bold=`tput smso` e_bold=`tput rmso`\n获取命令行参数 # shell中通过特殊变量获取，shell脚本执行时的命令行参数\n变量名 含义 $0 脚本名，与命令行输入脚本一致 $1,$2\u0026hellip;$9 第1到第9个参数，9个以上的参数将被忽略只能使用$@或$*获取 $# 参数个数 $@ 包含所有的1-9个参数 $* 包含所有的1-9个参数 $? 上一次命令执行的返回值（结果） $$ 执行脚本进程的PID 如果要对位置变量$1-$9赋值可以使用set One Two Three，对其依次赋值\nexit n表示退出当前shell，其中n就是返回值 shell脚本的返回值是最后一条执行指令的返回值，故如果最后为exit n则可指定脚本返回值。\n$@与$*区别在于用双引号括起来时的表现。不括起来含义相同。\nfor arg in \u0026#34;$@\u0026#34; do echo $arg # 将会依次打印每个参数 done for arg in \u0026#34;$*\u0026#34; do echo $arg # 循环只执行一次，一次打印全部参数 done 获取输入 # 使用read指令从输入设备中读取一行。第一个单词赋给第一个变量，第二个单词赋给第二个，如果给出的变量数量不够，则多余的全部赋给最后一个变量，如下。\nread one two rest # 假设输入为 1 2 3 4 5 # 则$one=1 $two=2 $rest=3 4 5 # read自动创建参数同名的变量 IFS变量影响read对单词的划分 即若IFS=:，则输入可为1:2:3:4\n简单函数 # # 定义 [ function ] funname [()] { action; [return int;] } # 像普通命令一样使用 funname 1 2 3 4 5 retrun可返回0-255作为函数的返回值，若无return则已最后一条指令执行结果为返回值。 在函数中使用特殊变量$1-$9 $#获取参数信息\n|| 条件与测试 # 条件结构 # UNIX中每条命令的执行都有返回值，UNIX通过对这个返回值测试提供了条件控制结构。\n若返回值为0则为真此时执行then后的语句块，非0则为假则执行else的。\n# 基础if-then结构 if cmd then commands fi # if-then-else结构 if cmd then true-commands else false-commands fi # if-then-elif结构 if cmd then true-commands elif cmd then commands else commands fi 测试指令 # 除一般sh命令外，shell还提供了专为条件测试使用的test内建命令，test根据参数进行比较后返回0或1。\nshell还提供了true，false的内建命令直接返回0和1\ntest提供了数值比较、字符串比较、文件测试\n数值比较\n比较参数 示例 含义 -eq num1 -eq num2 数值是否相等 -ne num1 -ne num2 是否不等 -gt num1 -gt num2 大于，greater than -ge num1 -ge num2 大于等于 -lt num1 -lt num2 小于 -le num1 -le num2 小于等于 纯数值比较也可以使用let \u0026quot;12\u0026lt;13\u0026quot;指令，此时是把比较表达式看作一个参数，test的则是表达式中所有元素均为参数（也就是均需要空格分隔）\n字符比较\n比较参数 含义 = 字符是否相等 != 是否不等 -n 是否长度非0 -z 是否长度为0 test使用方式是将操作数和比较符号均看作参数，所以=两边需要空格\n文件测试\n示列 含义 -r filename 文件是否存在并可读 -w filename 文件是否存在并可写 -s filename 文件是否存在并且大小非0 -f filename 文件是否存在且是普通文件 -d filename 文件是否存在且是目录 test指令还提供了逻辑参数，可以将多个比较表达式使用逻辑参数组合\n逻辑参数 含义 -a 与 -o 或 ! 非 [ contition ]可简写test condition，如下\n关于[[ condition ]]，[[]]是bash扩展的[]其功能类似，有以下区别 对于[ -z \u0026quot;$b\u0026quot; ] 可以直接使用 [[ -z $b ]]免去双引号 另外就是对于逻辑命令的引入\u0026amp;\u0026amp;和||等，[[ cond1 \u0026amp;\u0026amp; cond2]]，但在其中不可使用-a和-o等。另外\u0026amp;\u0026amp;和||等可直接对任意命令的结果进行逻辑运算\n# 为了避免$val为空导致参数错误，一般需要使用引号将变量括起来 if test \u0026#34;$val\u0026#34; -eq 1 then echo equal fi # []中前后必须要有空格 if [ \u0026#34;$val\u0026#34; -eq 1 ] then echo equal fi || 算数运算 # shell本身并不直接支持算符运算，而是通过命令方式提供，包括expr、let\nexpr # expr的使用方式类似test所有的元素均为参数需要空格隔开\n# expr只支持整数运算 expr 1 + 1 expr 2 - 1 expr 10 / 2 expr 2 \\* 3 expr 10 \\% 3 注意*，%等元字符需要手动转义 在bash中$((exp))形式同样可进行算数运算\nlet # let则是将整个表达式作为参数，且可直接赋值。\n# x为变量，此时无需使用$ let x=x+1 # let \u0026#34;x=x+1\u0026#34; let x=y*2 # let也可用作比较， x、y可为变量也可为整数字面量 let \u0026#34;x\u0026lt;y\u0026#34; 对于let的参数最好用\u0026quot;\u0026quot;包裹，避免元字符带来麻烦\n(( exp ))是let exp的简写\n(( x=x+1 )) (( \u0026#34;x=y*2\u0026#34; )) 同样(( ))中前后均需要空格\n|| 循环结构 # for-in-do-done # for用于遍历序列\nfor varname in list do commands done list是以空格为分隔的序列\nbreak 在循环中可以使用break指令跳出循环，break n表示跳出n重循环。\nwhile-do-done # while则是根据命令的执行结果决定是否执行循环，0则继续执行，非0则终止。\nwhile cmd do commands done cmd可为任意命令，自然也可以使用test、let及其简写\n循环重定向\nwhile read a b c do cmds done \u0026lt; TMP 该重定向对于该循环（无论执行几次）只会打开一次文件，然后再循环中依次读取一行，知道文件尾，read返回非0结束。\nutil-do-done # 基本结构同while，只是util条件与while相反，0则终止，非0继续执行\nutil cmd do commands done || 多路分支结构case # case varname in pattern_1) cmds last-cmd;; # 最后一条指令必须用;;结束 pattern_2) cmd;; *) # 默认分支，必须在最后 cmd;; esac 这里的pattern和前面介绍的文件名替换类似，还可使用|做逻辑组合\ncase $hour in 0?|1[01]) echo \u0026#34;Good Morning\u0026#34;;; 1[2-7]) echo \u0026#34;Good Afternoon\u0026#34;;; *) echo \u0026#34;Good Evening\u0026#34;;; esac || 捕获内核信号 # 内核信号\n编号 名称 含义 1 SIGHUP/挂起 终端断开时发送给该用户的所有进程 2 SIGINT/中断 按下中断建，如Ctrl+D、Ctrl+C 3 SIGQUIT/退出 按下退出键，如Ctrl+]，退出时会进行核心转储 9 SIGKILL/杀死 kill -9发出 15 SIGTERM/终止 kill -15发出 shell使用trap指令捕获信号，设置对于该信号的处理方式。 # 覆盖15信号的默认处理，转而执行echo trap \u0026#34;echo I refuse to die\u0026#34; 15 # 忽略2 3信号 trap \u0026#34;\u0026#34; 2 3 # 2 3信号复位默认处理方式 trap 2 3 || 调试shell程序 # 可以通过带选项的sh执行对脚本的调试\n选项 功能 -n 读取脚本但不执行，只进行语法检测 -v 每执行一条命令，都在stdout中显示原命令 -x 类似-v，但是显示的是变量替换完成后的命令 ","date":"19 June 2022","permalink":"/posts/linux-basis/shell-basis/","section":"Blogs","summary":"shell脚本基础语法（不全）","title":"shell基础"},{"content":" UNIX简介 # UNIX系统最初由贝尔实验室开发，随后发展为商用操作系统。 UNIX主要有两个版本：\nAT\u0026amp;T公司发布的System V 加利福利亚Berkeley分校 UNIX（BSD） 其他的UNIX系统变体基本都基于这个两个版本\n伯克利分校发布4.4BSD2后，BSD就停止发展了。 从这以后一些基于4.4BSD的版本如FreeBSD、OpenBSD仍在发展 AT\u0026amp;T的System V第四版（SVR4）是UNIX标准化的一个结果（系统调用接口）推动了可在所有UNIX上运行的程序的开发，该接口称为SVID（SV Interface Definition）。 而其他UNIX厂商联合相关UNIX产品开发商制定了POSIX（Portable Operating System Interface for Computer Environment）标准。 POSIX很大程度上基于SVID。\n|| 其他UNIX系统 # Linux # Linux不同于UNIX，是一个完全自由发布的UNIX版本。\n由于版权Linux不叫UNIX，但实际上它就是UNIX。Linux遵循很多与UNIX一样的标准\nSolaris # SunOS后称Solaris，最初是Sun公司基于SV2和BSD 4.3开发的。后Solaris2.0基于SVR4开发。\nUnixWare # UnixWare是基于SV系统的，只能用于Intel 处理器的计算机\nUNIX入门 # || UNIX登录过程 # UNIX完成启动后，init进程会为每个终端启动一个getty程序，负责在屏幕显示login:等信息并等待用户输入用户名，getty程序读取用户名后传递给login程序，然后login显示password:字符串并等待用户输入密码，login验证口令正确后则会根据用户定义启动一个shell程序，并进入用户主目录。\ngraph TB A(init进程)--\u0026gt;B(getty) B--\u0026gt;C(login) C--\u0026gt;D(shell) D--\u0026gt;A || UNIX用户 # 用户信息保存在/etc/passwd文件中，每个用户在该文件中用一行表示，每一行由7个用冒号分隔的字段表示。这些字段的含义如下：（按顺序）\nroot❌0:0::/root:/bin/bash login-name password，存储加密口令。SVR4中加密口令单独保存在/etc/shadow，此处使用x做占位符 user-id group-id user-info，用户描述字段 directory，用户主目录 program，指定登录后要运行的程序，一般是一个shell passwd命令可修改当前用户的口令。\n要添加/删除用户可以直接编辑/etc/passwd文件（需要root权限），但一般使用useradd指令更安全。\n|| UNIX简单命令 # 自行使用man或者\u0026ndash;help参数查看帮助\n显示日期与时间：date # 当前登录用户信息：who # 日历：cal # 获取帮助：\u0026ndash;help/man # ","date":"19 June 2022","permalink":"/posts/linux-basis/unix-introduction/","section":"Blogs","summary":"unix系统简介和入门知识","title":"UINIX简介与入门"},{"content":" UNIX文件系统简介 # || 文件系统基本原理 # UNIX文件系统采用索引节点（i节点）的方式实现。目录文件中仅包含文件名和i节点序号等基本信息，而i节点本身才包含文件存储物理位置、权限、时间戳等具体信息。 UNIX的i节点采用混合索引的方式，在缩影节点中包含10个直接地址项、1个一级简介地址项、1个二级简介地址项、1个三级间接地址项。\n|| 文件系统安全 # 每个文件和目录都拥有3组9位访问控制位实现文件保护，分别是拥有者权限位、同组用户权限位、其他用户权限位，每一组都包含rwx3位分别控制该对象是否拥有读、写、执行的权限。 目录文件具有x权限表示可以使用cd进入该目录或使用该目录作为路劲名的一部分。\n使用chmod可改变保护位，见下文 文件还有s权限，具体见sudo权限提升原理文档\n|| 挂载文件系统 # mount [opts] source dir # 卸载文件系统 umount [opts] dir 此时属于临时挂载，需要开机自动挂载需要编辑/etc/fstab文件。 添加一行内容：\n设备 挂载点 文件系统类型 挂载参数 是否备份 是否检测 /dev/sdb1 /mnt/newd linux defaults 0 0 执行mount -a可让文件立即生效。\nUNIX文件 # || UNIX文件简介 # 在UNIX中，文件就是字节序列，文件系统本身不支持带有结构的文件，这些是具体应用程序需要做的。\nUNIX文件类型 # 普通文件 目录文件 特殊文件，如系统中的设备均抽象为文件 隐藏文件 # 文件以.开头的为隐藏文件。 每个目录中都至少包含.当前目录和..上级目录\n|| 文件操作 # 这里只显示最简单的用法和参数，具体使用--help参数或者man命令\n创建\u0026amp;编辑文件 # UNIX中创建文件的方式有多种如下，\ntouch file创建空文件，一般touch用于更新时间戳，故只在文件不存在时创建目录 vim file cat \u0026gt; file，利用重定向和cat创建小文件（见下文） 编辑文件可使用vim、emacs等编辑器 复制/移动/删除文件：cp/mv/rm # cp复制文件\ncp [option]... source dest cp [option]... source... dir 选项 含义 -b 若目标文件已存在，则创建备份 -i 若目标文件已存在，要求确认 -f 文件存在，不提示直接覆盖 -r 递归拷贝所有子目录和子文件 mv移动文件\nmv [option]... source dest mv [option]... source... dir 选项 含义 -b 若目标文件已存在，则创建备份 -i 若目标文件已存在，要求确认 -f 若目标文件存在，不用确认直接覆盖 -r 递归移动所有子目录和子文件 mv命令可用作文件重命名\nrm删除文件\nrm [option]... file... 选项 含义 -i 删除是要求确认 -f 直接删除，忽略不存在文件，不提示 -r 递归删除目录 rm删除的文件不可恢复，需要谨慎使用 替代方案是将rm定义为mv的别名覆盖掉rm，如下\nalias rrm=\u0026#34;/usr/bin/rm\u0026#34; alias srm=trash alias rm=trash trash(){ mv $@ $HOME/.trash/\t} 显示文件：cat/head/tail # cat(concatenate)拼接多个文件 cat拼接多个文件（以及标准输入），并将结果输出到标准输出（所有文件内容）。\ncat [option]... file... 无参cat从标准输入读取输入直到eof（Ctrl+D），输出到标准输出。故可以结合重定向使用cat创建小文件。 另外若要连接文件和标准输入，cat file -其中-表示从标准输入读取。\nhead显示前多少项\nhead [option]... file... 同样-以及无参表示从标准输入中读取。\n选项 含义 -n -n 10即显示前10行，也可用-10替代，-n -10显示全部除了最后10行 -c -c 10显示前10个字节 tail显示后多少项\ntail [option]... file... 同样-以及无参表示从标准输入中读取。\n选项 含义 -n -n 10即显示后10行，也可用-10替代，-n +10表示从第10行开始到文件尾 -c -c 10显示后10个字节 分页显示文件：less/more # less和more指令都可以分页显示文件，特别对于查看大文件方便。 more只能往前查看，不能再倒回去 less可以向前后查看，操作方法类似vim\n链接文件：ln # ln [option]... target link_name 创建名为link_name的对target的硬连接。 -s选项指定创建软连接。\n硬连接则表示再link_name的目录项中直接插入名为linke_name的项，然后设置其i节点序号为target的 软连接则是创建名为link_name的链接文件，然后在该文件中存储traget的目录路径\n按域显示文件：cut # cut -f 1-3 file 表示显示file的第1到3列的内容\n选项 含义 -f 指定显示的域-f 1、-f 1,7、-f 1-7 -c 指定字符位置 -d 指定域分隔符（默认为空格制表符） 按行链接文件：paste # paste [opt]... file... 所有输入的文件的的行，拼接成新行，分隔符通过-d指定默认为制表符。\n文件内容计数：wc # wc -wlc test.c # 12 18 180 test.c 选项 含义 -w 统计单词数量 -c 统计字节数量 -l 统计行数 -m 统计字符数量 修改文件模式：chmod/chown/chgrp # chmod修改文件保护位\nchmod u+x file\t# 拥有者增加执行权限 chmod g+rw file\t# 组增加读写权限 chmod o+w file\t# 其他用户增加写权限 chmod o-r file\t# 其他用户减少读权限 chmod a+w file\t# 全部（三组）都增加写权限 chmod a=rwx file# 全部都设为rwx chmod +s file\t# 增加s权限 # 也可以采用八进制的方式 # 例如 u(rwx) g(r-x) o(r-x) # 即u(111) g(101) o(101) # 即u(7) g(5) o(5) chmod 755 file chown修改拥有者\n# 修改拥有者为root，当然需要root权限 chown root file chgrp修改所属组\n# 修改组为root，当然需要root权限 chgrp root file 查找文件位置：find # find start_dir \u0026lt;opt\u0026gt; 选项 含义 -name filename 根据指定文件名查找，filename可以使用通配符，含义和文件名替换类似，需要使用引号括起来避免被替换。 -size +-n 指定查找文件大小（块），-size +10表示大于10块的，-10表示小于10块的 -type ft 指定查找文件类型，ft可以为b块设备文件、c字符设备文件、d目录文件、f普通文件 -atime +-n 指定访问时间（天），同样可给出+-表示范围 -mtime +-n 指定修改时间（天），同样可给出+-表示范围 -newer filename 比filename更新的文件 -print 找到文件后打印文件路径（默认） -exec cmd ; 找到（每个）文件后执行cmd -ok cmd ; 找到（每个）文件后先询问，再执行cmd 查找文件内容：grep # 该命令在文件中查找指定模式，找到则显示整行。\ngrep [option]... patterns [file]... 同样但不指定文件时从标准输入中读取内容并查找。\n选项 含义 -c 显示每个文件中匹配的行数 -i 匹配时忽略大小写 -l 只显示含有匹配模式的文件名，而不显示具体的匹配行 -n 每个输出行前显示行号 -v 显示与模式不匹配的行 文件归档\u0026amp;压缩 # 压缩和归档是两会事情。 tar指令可将多个文档归档（解开）为一个文件，此时并未进行压缩，只是为压缩提供了条件（因为有些压缩算法只支持对单个文件压缩如gzip）。\ntar为了方便使用也提供了参数，在归档完成后可以立即进行压缩\ntar -cvf archive.tar file1 file2 dir tar -xvf archive.tar -C dest_dir # 对应加解档参数前添加需要的压缩算法参数即可 tar -zcf archive.tar.gz file1 file tar -zxf archive.tar.gz tar部分参数\n选项 含义 -c 创建归档 -f 指定归档文件 -r 增加文件到归档文件 -t 列出归档中的文件 -x 解开归档文件 -v verbose显示详细创建/解档过程 -z 归档后用gzip算法压缩 -j 归档后用bzip2算法压缩 || 文件名替换 # 使用shell元字符*、[]、?替换\n见shell基础\u0026amp;编程文档中元字符一节\n|| shell重定向 # 使用\u0026gt;、\u0026gt;\u0026gt;、\u0026lt;、\u0026lt;\u0026lt;重定向输入输出到文件\n见shell基础\u0026amp;编程文档中I/O重定向一节\nUNIX目录 # || 目录相关概念 # UNIX重要目录 # 目录 说明 / 根目录 /usr 面向用户的目录 /usr/bin/面向用户的可执行文件 /usr/sbin/系统管理文件 /bin 存放基本UNIX程序 /dev 存放设备文件 /sbin 存放系统文件，通常由UNIX自行运行 /etc 存放配置文件 用户主目录 # 每个用户都有一个自己的主目录\n当前工作目录 # shell当前工作的目录，可提供给相对路径使用。 pwdprint work dir可打印当前的工作目录 cd dir切换工作目录到dir\n绝对路径与相对路径 # /开头的为绝对路径。 相对路径是为了用户使用方便以及减少目录的查询时间，即从当前的工作目录开始查找。\n|| 目录操作 # 创建目录：mkdir # mkdir -p /usr/home/xui/new_dir -p参数表示不存在的父目录也一同创建。\n列出目录项：ls # 选项 说明 -a 列出全部，包括隐藏 -C 用多列格式列出，按列排序 -F 目录后加/，可执行文件后加* -l 长格式显示，即显示文件详细信息 -m 按页宽显示，用逗号隔开 -p 目录后加/ -r 字母反序排列 -R 递归列出子目录 -s 以块为单位 -x 以多列格式列出，以行排序 -h 人类可读的单位 删除空目录：rmdir # rmdir dir 若dir不为空需要使用rm删除\n","date":"19 June 2022","permalink":"/posts/linux-basis/unix-file-system-intro/","section":"Blogs","summary":"UNIX文件系统基本原理与简单使用","title":"UNIX文件系统操作"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]