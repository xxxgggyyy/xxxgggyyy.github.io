<!doctype html><html lang=en dir=ltr class=scroll-smooth data-default-appearance=dark data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="en"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><title>Leetcode - DP problems &#183; Xgy's Blogs</title>
<meta name=title content="Leetcode - DP problems &#183; Xgy's Blogs"><meta name=description content="leetcode中动态规划相关题目"><meta name=keywords content="algorithm,ds,leetcode,dp,"><link rel=canonical href=https://xxxgggyyy.github.io/posts/algorithms-and-data-structures/dynamic-planning/dp-leetcode/><link type=text/css rel=stylesheet href=/css/main.bundle.min.b0d4aeb65335611c810957fcff4af94f45bb796b37facd9be6f7287ee03ce57038918ff5d4ac7a6ea77914fde6d3942c0243d3d17f90926c454b4ea3499e973a.css integrity="sha512-sNSutlM1YRyBCVf8/0r5T0W7eWs3+s2b5vcofuA85XA4kY/11Kx6bqd5FP3m05QsAkPT0X+QkmxFS06jSZ6XOg=="><script type=text/javascript src=/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj+e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script><script defer type=text/javascript id=script-bundle src=/js/main.bundle.min.597628986858b13a494c65a74833a8574811213e1948854f9cf3bedab1397e94112500c1f9d89ec839cfc9fd23ecf052499a13b2dcab9a4b36598a478a01899c.js integrity="sha512-WXYomGhYsTpJTGWnSDOoV0gRIT4ZSIVPnPO+2rE5fpQRJQDB+dieyDnPyf0j7PBSSZoTstyrmks2WYpHigGJnA==" data-copy data-copied></script><script src=/js/zoom.min.js></script><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:title" content="Leetcode - DP problems"><meta property="og:description" content="leetcode中动态规划相关题目"><meta property="og:type" content="article"><meta property="og:url" content="https://xxxgggyyy.github.io/posts/algorithms-and-data-structures/dynamic-planning/dp-leetcode/"><meta property="og:image" content="https://xxxgggyyy.github.io/posts/algorithms-and-data-structures/dynamic-planning/dp-leetcode/feature-dp.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-10T19:47:50+08:00"><meta property="article:modified_time" content="2024-01-10T19:47:50+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://xxxgggyyy.github.io/posts/algorithms-and-data-structures/dynamic-planning/dp-leetcode/feature-dp.png"><meta name=twitter:title content="Leetcode - DP problems"><meta name=twitter:description content="leetcode中动态规划相关题目"><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Blogs","name":"Leetcode - DP problems","headline":"Leetcode - DP problems","abstract":"leetcode中动态规划相关题目","inLanguage":"en","url":"https:\/\/xxxgggyyy.github.io\/posts\/algorithms-and-data-structures\/dynamic-planning\/dp-leetcode\/","author":{"@type":"Person","name":"xxxgggyyy"},"copyrightYear":"2024","dateCreated":"2024-01-10T19:47:50\u002b08:00","datePublished":"2024-01-10T19:47:50\u002b08:00","dateModified":"2024-01-10T19:47:50\u002b08:00","keywords":["algorithm","ds","leetcode","dp"],"mainEntityOfPage":"true","wordCount":"3237"}]</script><meta name=author content="xxxgggyyy"><link href=https://github.com/xxxgggyyy rel=me><link href=mailto:xie_guoyi@foxmail.com rel=me><script src=/lib/jquery/jquery.slim.min.js integrity></script><link type=text/css rel=stylesheet href=/lib/katex/katex.min.7c7c1a59e6eec00ecd485e5083f69fe14783c7d5ea52962938682e6e8df25aef9bd88411e14790c1b6f8d938bb81502336d56823f23d4c4a187aef689b0702ea.css integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g=="><script defer src=/lib/katex/katex.min.2d037120c479ad7bfba3e6f597cf8dd4464c7e11bb88567d1e19db2644e9e338cdaf95afb2def902a51e143c5e4546bb979bc40f2522022a7ffebf8414b2c2c8.js integrity="sha512-LQNxIMR5rXv7o+b1l8+N1EZMfhG7iFZ9HhnbJkTp4zjNr5Wvst75AqUeFDxeRUa7l5vEDyUiAip//r+EFLLCyA=="></script><script defer src=/lib/katex/auto-render.min.8968ae052e67b7aafad1f0b3dba35dd19a9ed276e4d594c841b9772afee462c5fec8a314147ce3687dbe02733abe9d97b3e80d99a0405562634a6b8fc3be847e.js integrity="sha512-iWiuBS5nt6r60fCz26Nd0Zqe0nbk1ZTIQbl3Kv7kYsX+yKMUFHzjaH2+AnM6vp2Xs+gNmaBAVWJjSmuPw76Efg==" onload=renderMathInElement(document.body)></script><meta name=theme-color></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>Skip to main content</a></div><div class=min-h-[148px]></div><div class="fixed inset-x-0 pl-[24px] pr-[24px]" style=z-index:100><div id=menu-blur class="absolute opacity-0 inset-x-0 top-0 h-full single_hero_background nozoom backdrop-blur-2xl shadow-2xl"></div><div class="relative max-w-[64rem] ml-auto mr-auto"><div style=padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start space-x-3"><div><a href=/ class=flex><span class=sr-only>Xgy&rsquo;s Blogs</span>
<img src=/img/little_cat1.png width=697 height=689 class="logo max-h-[5rem] max-w-[5rem] object-scale-down object-left nozoom" alt="Xgy's Blogs"></a></div><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/ class="text-base font-medium text-gray-500 hover:text-gray-900">Xgy&rsquo;s Blogs</a></nav><nav class="hidden md:flex items-center space-x-5 md:ml-12 h-12"><a href=/posts/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Blog</p></a><a href=/series/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Series</p></a><a href=/topics/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Topics</p></a><a href=/tags/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-base font-medium" title>Tags</p></a><a href=https://github.com/xxxgggyyy target=_blank class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><span><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></span><p class="text-base font-medium" title></p></a><button id=search-button aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></button><div class="ltr:mr-14 rtl:ml-14 flex items-center"><button id=appearance-switcher aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400"><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></nav><div class="flex md:hidden items-center space-x-5 md:ml-12 h-12"><span></span>
<button id=search-button-mobile aria-label=Search class="text-base hover:text-primary-600 dark:hover:text-primary-400" title>
<span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg>
</span></button>
<button id=appearance-switcher-mobile aria-label="Dark mode switcher" type=button class="text-base hover:text-primary-600 dark:hover:text-primary-400" style=margin-right:5px><div class="flex items-center justify-center dark:hidden"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M32 256C32 132.2 132.3 32 255.8 32c11.36.0 29.7 1.668 40.9 3.746 9.616 1.777 11.75 14.63 3.279 19.44C245 86.5 211.2 144.6 211.2 207.8c0 109.7 99.71 193 208.3 172.3 9.561-1.805 16.28 9.324 10.11 16.95C387.9 448.6 324.8 480 255.8 480 132.1 480 32 379.6 32 256z"/></svg></span></div><div class="items-center justify-center hidden dark:flex"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M256 159.1c-53.02.0-95.1 42.98-95.1 95.1s41.2 96.9 95.1 96.9 95.1-42.98 95.1-95.1S309 159.1 256 159.1zM509.3 347l-63.2-91.9 63.15-91.01c6.332-9.125 1.104-21.74-9.826-23.72l-109-19.7-19.7-109c-1.975-10.93-14.59-16.16-23.72-9.824L256 65.89 164.1 2.736c-9.125-6.332-21.74-1.107-23.72 9.824L121.6 121.6 12.56 141.3C1.633 143.2-3.596 155.9 2.736 164.1L65.89 256 2.74 347.01c-6.332 9.125-1.105 21.74 9.824 23.72l109 19.7 19.7 109c1.975 10.93 14.59 16.16 23.72 9.824L256 446.1l91.01 63.15c9.127 6.334 21.75 1.107 23.72-9.822l19.7-109 109-19.7C510.4 368.8 515.6 356.1 509.3 347zM256 383.1c-70.69.0-127.1-57.31-127.1-127.1.0-70.69 57.31-127.1 127.1-127.1S383.1 186.2 383.1 256c0 70.7-56.4 127.1-127.1 127.1z"/></svg></span></div></button></div></div><div class="-my-2 -mr-2 md:hidden"><label id=menu-button for=menu-controller class=block><input type=checkbox id=menu-controller class=hidden><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentcolor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper style=padding-top:5px class="fixed inset-0 z-30 invisible w-screen h-screen m-0 overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50"><ul class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl"><li><span class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mt-1><a href=/posts/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Blog</p></a></li><li class=mt-1><a href=/series/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Series</p></a></li><li class=mt-1><a href=/topics/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Topics</p></a></li><li class=mt-1><a href=/tags/ class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><p class="text-bg font-bg" title>Tags</p></a></li><li class=mt-1><a href=https://github.com/xxxgggyyy target=_blank class="flex items-center text-gray-500 hover:text-primary-600 dark:hover:text-primary-400"><div><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></div><p class="text-bg font-bg" title></p></a></li></ul><hr><ul class="flex mt-4 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl"><li class=mb-1><a href class="flex items-center"><p class="text-sm font-sm text-gray-500 hover:text-gray-900" title>CS Basis</p></a></li><li class=mb-1><a href=/topics/c-family/ class="flex items-center"><p class="text-sm font-sm text-gray-500 hover:text-gray-900" title>C Family</p></a></li></ul></div></label></div></div><div class="main-menu flex pb-3 flex-col items-end justify-between md:justify-start space-x-3" style=margin-top:-15px><div class="hidden md:flex items-center space-x-5"><a href class="flex items-center"><p class="text-xs font-light text-gray-500 hover:text-gray-900" title>CS Basis</p></a><a href=/topics/c-family/ class="flex items-center"><p class="text-xs font-light text-gray-500 hover:text-gray-900" title>C Family</p></a></div></div><script>(function(){var e=$(".main-menu"),t=window.location.pathname;e.find('a[href="'+t+'"]').each(function(e,t){$(t).children("p").addClass("active")})})()</script></div></div><script>window.addEventListener("scroll",function(){var t=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,n=document.getElementById("menu-blur");n.style.opacity=t/300})</script><div class="relative flex flex-col grow"><main id=main-content class=grow><article><header id=single_header class="mt-5 max-w-prose"><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">Leetcode - DP problems</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2024-01-10 19:47:50 +0800 +0800">10 January 2024</time><span class="px-2 text-primary-500">&#183;</span><span>3237 words</span><span class="px-2 text-primary-500">&#183;</span><span title="Reading time">16 mins</span><span class="px-2 text-primary-500">&#183;</span>
<script type=text/javascript src=/js/zen-mode.min.16f2e42a0014d476212e14c056b26b69bc85cb5de15352a5e3a1a0be498055dc1bf0926cef44baef1cc7fa2dfc5de0052892645cd3766598065f47b15c4bd44d.js integrity="sha512-FvLkKgAU1HYhLhTAVrJrabyFy13hU1Kl46GgvkmAVdwb8JJs70S67xzH+i38XeAFKJJkXNN2ZZgGX0exXEvUTQ=="></script><span class=mb-[2px]><span id=zen-mode-button class="text-lg hover:text-primary-500" title="Enable zen mode" data-title-i18n-disable="Enable zen mode" data-title-i18n-enable="Disable zen mode"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="50" height="50"><path fill="currentcolor" d="M12.980469 4C9.1204688 4 5.9804688 7.14 5.9804688 11L6 26H9.9804688V11c0-1.65 1.3400002-3 3.0000002-3H40.019531c1.66.0 3 1.35 3 3V39c0 1.65-1.34 3-3 3H29c0 1.54-.579062 2.94-1.539062 4H40.019531c3.86.0 7-3.14 7-7V11c0-3.86-3.14-7-7-7H12.980469zM7 28c-2.206.0-4 1.794-4 4V42c0 2.206 1.794 4 4 4H23c2.206.0 4-1.794 4-4V32c0-2.206-1.794-4-4-4H7zm0 4H23L23.001953 42H7V32z"/></svg></span></span></span></span></div><div class="flex flex-row flex-wrap items-center"><span style=margin-top:.5rem class=mr-2 onclick='window.open("/tags/algorithm/","_self")'><span class=flex style=cursor:pointer><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Algorithm
</span></span></span><span style=margin-top:.5rem class=mr-2 onclick='window.open("/tags/ds/","_self")'><span class=flex style=cursor:pointer><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Ds
</span></span></span><span style=margin-top:.5rem class=mr-2 onclick='window.open("/tags/leetcode/","_self")'><span class=flex style=cursor:pointer><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Leetcode
</span></span></span><span style=margin-top:.5rem class=mr-2 onclick='window.open("/tags/dp/","_self")'><span class=flex style=cursor:pointer><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Dp
</span></span></span><span style=margin-top:.5rem class=mr-2 onclick='window.open("/topics/algorithms-and-data-structures/","_self")'><span class=flex style=cursor:pointer><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">Algorithms and Data Structures</span></span></span></div></div><div class="flex author"><img class="!mt-0 !mb-0 h-24 w-24 rounded-full ltr:mr-4 rtl:ml-4" width=96 height=96 alt=xxxgggyyy src=/img/little_cat2_hue9517b3b0042cf4786c2fe7711a7cd24_1977661_192x192_fill_q75_box_center.jpg><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">Author</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">xxxgggyyy</div><div class="text-sm text-neutral-700 dark:text-neutral-400">May be a tech geek?</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=https://github.com/xxxgggyyy target=_blank aria-label=Github rel="me noopener noreferrer"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg>
</span></span></a><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=mailto:xie_guoyi@foxmail.com target=_blank aria-label=Email rel="me noopener noreferrer"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg></span></span></a></div></div></div></div><div class=mb-5></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first lg:ml-auto px-0 lg:order-last ltr:lg:pl-8 rtl:lg:pr-8"><div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-[140px]"><details open class="toc-right mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="min-w-[220px] py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#leetcode动态规划>leetcode动态规划</a><ul><li><a href=#-理论>|| 理论</a></li><li><a href=#-leetcode题目>|| leetcode题目</a><ul><li><a href=#509斐波那契数>509.斐波那契数</a></li><li><a href=#70爬梯子>70.爬梯子</a></li><li><a href=#746-使用最小花费爬楼梯>746. 使用最小花费爬楼梯</a></li><li><a href=#62-不同路径>62. 不同路径</a></li><li><a href=#63-不同路径-ii>63. 不同路径 II</a></li><li><a href=#343-整数拆分>343. 整数拆分</a></li><li><a href=#96不同的二叉搜索树>96.不同的二叉搜索树</a></li><li><a href=#416-分割等和子集>416. 分割等和子集</a></li><li><a href=#1049-最后一块石头的重量-ii>1049. 最后一块石头的重量 II</a></li><li><a href=#494-目标和>494. 目标和</a></li><li><a href=#474一和零>474.一和零</a></li><li><a href=#完全背包问题基础>[完全背包问题基础]</a></li><li><a href=#518-零钱兑换-ii>518. 零钱兑换 II</a></li><li><a href=#377-组合总和->377. 组合总和 Ⅳ</a></li><li><a href=#322-零钱兑换>322. 零钱兑换</a></li><li><a href=#279完全平方数>279.完全平方数</a></li><li><a href=#139-单词拆分>139. 单词拆分</a></li><li><a href=#198-打家劫舍>198. 打家劫舍</a></li><li><a href=#213打家劫舍ii>213.打家劫舍II</a></li><li><a href=#337打家劫舍-iii>337.打家劫舍 III</a></li><li><a href=#647-回文子串>647. 回文子串</a></li><li><a href=#516最长回文子序列>516.最长回文子序列</a></li><li><a href=#5-最长回文子串>5. 最长回文子串</a></li><li><a href=#121-买卖股票的最佳时机>121. 买卖股票的最佳时机</a></li><li><a href=#122-买卖股票的最佳时机-ii>122. 买卖股票的最佳时机 II</a></li><li><a href=#300-最长递增子序列>300. 最长递增子序列</a></li><li><a href=#236-二叉树的最近公共祖先>236. 二叉树的最近公共祖先</a></li></ul></li></ul></li></ul></nav></div></details><details class="toc-inside mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#leetcode动态规划>leetcode动态规划</a><ul><li><a href=#-理论>|| 理论</a></li><li><a href=#-leetcode题目>|| leetcode题目</a><ul><li><a href=#509斐波那契数>509.斐波那契数</a></li><li><a href=#70爬梯子>70.爬梯子</a></li><li><a href=#746-使用最小花费爬楼梯>746. 使用最小花费爬楼梯</a></li><li><a href=#62-不同路径>62. 不同路径</a></li><li><a href=#63-不同路径-ii>63. 不同路径 II</a></li><li><a href=#343-整数拆分>343. 整数拆分</a></li><li><a href=#96不同的二叉搜索树>96.不同的二叉搜索树</a></li><li><a href=#416-分割等和子集>416. 分割等和子集</a></li><li><a href=#1049-最后一块石头的重量-ii>1049. 最后一块石头的重量 II</a></li><li><a href=#494-目标和>494. 目标和</a></li><li><a href=#474一和零>474.一和零</a></li><li><a href=#完全背包问题基础>[完全背包问题基础]</a></li><li><a href=#518-零钱兑换-ii>518. 零钱兑换 II</a></li><li><a href=#377-组合总和->377. 组合总和 Ⅳ</a></li><li><a href=#322-零钱兑换>322. 零钱兑换</a></li><li><a href=#279完全平方数>279.完全平方数</a></li><li><a href=#139-单词拆分>139. 单词拆分</a></li><li><a href=#198-打家劫舍>198. 打家劫舍</a></li><li><a href=#213打家劫舍ii>213.打家劫舍II</a></li><li><a href=#337打家劫舍-iii>337.打家劫舍 III</a></li><li><a href=#647-回文子串>647. 回文子串</a></li><li><a href=#516最长回文子序列>516.最长回文子序列</a></li><li><a href=#5-最长回文子串>5. 最长回文子串</a></li><li><a href=#121-买卖股票的最佳时机>121. 买卖股票的最佳时机</a></li><li><a href=#122-买卖股票的最佳时机-ii>122. 买卖股票的最佳时机 II</a></li><li><a href=#300-最长递增子序列>300. 最长递增子序列</a></li><li><a href=#236-二叉树的最近公共祖先>236. 二叉树的最近公共祖先</a></li></ul></li></ul></li></ul></nav></div></details><script>(function(){var t,e=$("#TableOfContents");if(e.length>0){t=$(window);function n(){var s,o=t.scrollTop(),i=$(".anchor"),n="";if(i.each(function(e,t){t=$(t),t.offset().top-$(window).height()/3<=o&&(n=t.attr("id"))}),s=e.find("a.active"),s.length==1&&s.eq(0).attr("href")=="#"+n)return!0;s.each(function(e,t){$(t).removeClass("active")}),e.find('a[href="#'+n+'"]').addClass("active"),e.find('a[href="#'+n+'"]').parentsUntil("#TableOfContents").each(function(e,t){$(t).children("a").parents("ul").show()})}t.on("scroll",n),$(document).ready(function(){n()})}})()</script></div></div><div class="min-w-0 min-h-0 max-w-fit"><div class="article-content max-w-prose mb-20"><h1 class="relative group">leetcode动态规划<div id=leetcode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#leetcode%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92 aria-label=Anchor>#</a></span></h1><h2 class="relative group">|| 理论<div id=-%E7%90%86%E8%AE%BA class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#-%E7%90%86%E8%AE%BA aria-label=Anchor>#</a></span></h2><ul><li>具有重叠子问题，明确子问题含义</li><li>写出递归方程（状态转移方程）</li><li>使用簿记变量以及确定初始化值</li></ul><blockquote><p>很熟悉了不再赘述</p></blockquote><h2 class="relative group">|| leetcode题目<div id=-leetcode%E9%A2%98%E7%9B%AE class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#-leetcode%E9%A2%98%E7%9B%AE aria-label=Anchor>#</a></span></h2><h3 class="relative group">509.斐波那契数<div id=509%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#509%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0 aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/fibonacci-number/ target=_blank>https://leetcode.cn/problems/fibonacci-number/</a></p><p>斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：</p><pre><code>F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1
</code></pre><p>给定 n ，请计算 F(n) 。</p><p><em>题解：</em></p><p>没什么好解的，用两个变量递推就是了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fib</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>f1</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>f2</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>||</span> <span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>f2</span> <span class=o>=</span> <span class=n>f1</span> <span class=o>+</span> <span class=n>f2</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>(</span><span class=n>f1</span><span class=p>,</span> <span class=n>f2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>f1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>官方题解里还有两个有趣的解法，这里简单说说：</p><ol><li>直接写出齐次线性方程通解</li><li>矩阵快速幂，就是写出矩阵递归形式，完了求$M^n$，就是个简单2分n的快速幂求乘法。</li></ol><h3 class="relative group">70.爬梯子<div id=70%E7%88%AC%E6%A2%AF%E5%AD%90 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#70%E7%88%AC%E6%A2%AF%E5%AD%90 aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/climbing-stairs/ target=_blank>https://leetcode.cn/problems/climbing-stairs/</a></p><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><em>题解：</em></p><p>状态方程可写为：</p><p>$$
dp[n] = dp[n-1] + dp[n-2]
$$</p><p>$dp[n]$表示高为$n$的阶梯有多少种走法。</p><p>和上一题斐波那契数列完全相同，只是初始值不同，这里直接用上一题的代码改一改。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>climbStairs</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>f1</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>f2</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>n</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>f2</span> <span class=o>=</span> <span class=n>f1</span> <span class=o>+</span> <span class=n>f2</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>(</span><span class=n>f1</span><span class=p>,</span> <span class=n>f2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>f1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">746. 使用最小花费爬楼梯<div id=746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/min-cost-climbing-stairs/ target=_blank>https://leetcode.cn/problems/min-cost-climbing-stairs/</a></p><p>给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。</p><p>你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。</p><p>请你计算并返回达到楼梯顶部的最低花费。</p><p><em>题解</em></p><blockquote><p>看似和上两题有点类似，但子问题含义完全不一样</p></blockquote><p>设$dp[s]$为<code>s</code>阶楼梯的最小花费，状态转移方程为：</p><p>$$
dp[s] = min
\begin{cases}
dp[s-1] + cost[s-1],\
dp[s-2] + cost[s-2]
\end{cases} \
dp[0] = 0, dp[1] = 0
$$</p><p>需要注意<strong>初始值</strong>，由于可以从下标0或1直接开始，所以初始值为0</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>minCostClimbingStairs</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>cost</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// -1, -2
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=kt>int</span> <span class=n>dp1</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>dp2</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>cost</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>dp2</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>dp1</span> <span class=o>+</span> <span class=n>cost</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>],</span> <span class=n>dp2</span> <span class=o>+</span> <span class=n>cost</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>2</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>(</span><span class=n>dp1</span><span class=p>,</span> <span class=n>dp2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">62. 不同路径<div id=62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84 aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/unique-paths/ target=_blank>https://leetcode.cn/problems/unique-paths/</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><em>题解</em></p><p>首先想到的是动规，再加上滚动数组优化，代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>uniquePaths</span><span class=p>(</span><span class=kt>int</span> <span class=n>m</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>m</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>+=</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>m</span><span class=o>-</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>不用滚动数组，最原始的<code>dp[i][j]</code>的含义为，从<code>(i, j)</code>出发走到终点有多少条路径。状态转移方程太简单不在赘述。</p><p>官方题解中还有一种使用组合数学的方法，走到终点一定要<code>m+n-2</code>步，而向下一定要走<code>m-1</code>步，当我们确定了<code>m+n-2</code>中何时向下走的<code>m-1</code>步，
剩下的<code>n-1</code>步自然就是向右走的。</p><p>所以问题变为了从<code>m+n-2</code>中选择<code>m-1</code>个数，求$C_{m+n-2}^{m-1}$</p><blockquote><p>求组合数注意溢出</p></blockquote><h3 class="relative group">63. 不同路径 II<div id=63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-ii class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-ii aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/unique-paths-ii/ target=_blank>https://leetcode.cn/problems/unique-paths-ii/</a></p><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。</p><p>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？</p><p>网格中的障碍物和空位置分别用 1 和 0 来表示。</p><p><em>题解</em></p><p>这题和上一题思路一致，动规加滚动数组优化。</p><p>但需要注意两点：</p><ol><li><p>有障碍物的地方<code>dp[i][j]</code>可以置为0，不影响状态转移方程（反正都是左+右，为0正好对应走不通）</p></li><li><p>初始值，对于最后一行，只有存在一个障碍物，那么障碍物之前的<code>dp</code>的值也为0，因为现在只向右边走，走不通了</p></li></ol><p>代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>uniquePathsWithObstacles</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;&amp;</span> <span class=n>obstacleGrid</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>m</span> <span class=o>=</span> <span class=n>obstacleGrid</span><span class=p>.</span><span class=n>size</span><span class=p>(),</span> <span class=n>n</span> <span class=o>=</span> <span class=n>obstacleGrid</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=n>n</span><span class=o>-</span><span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span><span class=mi>0</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>obstacleGrid</span><span class=p>[</span><span class=n>m</span> <span class=o>-</span> <span class=mi>1</span><span class=p>][</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>while</span><span class=p>(</span><span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>m</span> <span class=o>-</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span><span class=mi>0</span> <span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>obstacleGrid</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>n</span> <span class=o>-</span> <span class=mi>2</span><span class=p>;</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span><span class=o>--</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>obstacleGrid</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>+=</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><blockquote><p>上一题是用的列dp，这里由于<code>obstacleGrid</code>是行主序的，这里改成了行dp最大化利用cache。</p></blockquote><blockquote><p>另外第一次提交<code>int</code>溢出了改成<code>long long</code>通过</p></blockquote><h3 class="relative group">343. 整数拆分<div id=343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86 aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/integer-break/ target=_blank>https://leetcode.cn/problems/integer-break/</a></p><p>给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。</p><p>返回 你可以获得的最大乘积 。</p><p><em>题解</em></p><p>最开始的做法搞复杂了，设<code>dp[k][n]</code>表示n拆为k个数时最大乘积。</p><p>状态转移方程为：</p><p>$$
dp[k][n] = max_{1&lt;=i&lt;=n-k+1}(i*dp[k-1][n-i])
$$</p><p>其初始值和遍历顺序见代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#define INX(x, y) (x)*(n+1) + (y)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>integerBreak</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span><span class=o>*</span> <span class=n>dp</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>*</span><span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// initializing
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>INX</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>i</span><span class=p>)]</span> <span class=o>=</span> <span class=p>(</span><span class=n>i</span> <span class=o>/</span> <span class=mi>2</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>i</span> <span class=o>/</span> <span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>INX</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>i</span><span class=p>)]</span> <span class=o>&gt;</span> <span class=n>ret</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>ret</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>INX</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>i</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=kt>int</span> <span class=n>tmp_max</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>j</span> <span class=o>-</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                    <span class=n>tmp</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>INX</span><span class=p>(</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>j</span><span class=o>-</span><span class=n>k</span><span class=p>)]</span> <span class=o>*</span> <span class=n>k</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span><span class=p>(</span><span class=n>tmp</span> <span class=o>&gt;</span> <span class=n>tmp_max</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=n>tmp_max</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>INX</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)]</span> <span class=o>=</span> <span class=n>tmp_max</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>tmp_max</span> <span class=o>&gt;</span> <span class=n>ret</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>ret</span> <span class=o>=</span> <span class=n>tmp_max</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>如果说这题要求k的个数到也勉强说的过去。</p><blockquote><p>其实可能多个不同的k的乘积一样大，所以这里没有要求k</p></blockquote><p>再说标准的做法，设<code>dp[n]</code>为至少拆成2个数时的最大乘积。</p><p>状态转移方程为：</p><p>$$
dp[n] = j*max_{1&lt;=j&lt;n}(i-j, dp[i-j])
$$</p><p>之所以有个<code>i-j</code>是<code>dp[k]</code>含义为至少拆成2，所以<code>j*dp[i-j]</code>表示至少拆成3个数，没有考虑拆成两个的情况，所以这里有个<code>j*(i-j)</code></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>integerBreak</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span> <span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>curMax</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>curMax</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>curMax</span><span class=p>,</span> <span class=n>max</span><span class=p>(</span><span class=n>j</span> <span class=o>*</span> <span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>j</span><span class=p>),</span> <span class=n>j</span> <span class=o>*</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=n>j</span><span class=p>]));</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>curMax</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>最后这里其实有一种巧妙的解法，如果拆成的乘积中存在因数$f>=4$，那么f总能被拆为2*(f-2)
因为$2f-4>=4$，所以最大乘积中一定只能被拆为1、2、3的组合，而如果存在1又总能被加到2或者3上重新拆，所以最后结果只需要2、3就能组合成。</p><p>但其实最终结果中2的次数不会多于两次，因为$2<em>2</em>2 &lt; 3*3$。</p><p>所以可能的最大乘积的组合一定只会是以下3种可能：</p><ul><li>$3<em>3</em>3&mldr;*3$</li><li>$2<em>3</em>3*3&mldr;*3$</li><li>$2<em>2</em>3<em>3</em>3&mldr;*3$</li></ul><p>并且这三种可能是不能相互转换的，$3^k = 2*3^m$ => $3^{k-m}=2$显然不成立，另一个等式同理。</p><p>所以，只要求出其中一种可能就只能是这种，不可能是其他两种。而恰好直接除3，根据余数情况可以分别得出这三种情况：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>integerBreak</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>n</span> <span class=o>&lt;=</span> <span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=p>(</span><span class=n>n</span><span class=o>/</span><span class=mi>2</span><span class=p>)</span> <span class=o>*</span> <span class=p>(</span><span class=n>n</span> <span class=o>-</span> <span class=n>n</span><span class=o>/</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>r</span> <span class=o>=</span> <span class=n>n</span> <span class=o>%</span> <span class=mi>3</span><span class=p>,</span> <span class=n>p</span> <span class=o>=</span> <span class=n>n</span> <span class=o>/</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>r</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>pow</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>r</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>4</span> <span class=o>*</span> <span class=n>pow</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=n>p</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>2</span> <span class=o>*</span> <span class=nf>pow</span><span class=p>(</span><span class=mi>3</span><span class=p>,</span> <span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">96.不同的二叉搜索树<div id=96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91 aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/unique-binary-search-trees/ target=_blank>https://leetcode.cn/problems/unique-binary-search-trees/</a></p><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的<strong>二叉搜索树</strong>有多少种？返回满足题意的二叉搜索树的种数。</p><p>题解：</p><p>需要观察到题中为二叉排序树数量。如此一来根据排序树的性质（左子树所有值小于root，右子树所有值大于root，且左右子树也是排序树），就很容易发现子问题了。</p><p>设<code>dp[k]</code>为当<code>n=k</code>时，二叉排序树的数量，其状态转移方式如下：</p><p>$$
dp[k] = \sum_{i=1}^{k}dp[i-i]*dp[k-i] \
dp[0] = 1, dp[1] = 1
$$</p><p>通俗来说，当有<code>n</code>个节点时，可以设根节点为<code>k</code>由于节点的值是<code>1~n</code>，所以按照排序树的性质，左子树的值一定是小于<code>k</code>的，右子树一定是大于<code>k</code></p><p>所以左子树变为了有<code>k-1</code>的节点时，有多少种排序树（这就是子问题了）。知道知道左右子树相乘极为根为<code>k</code>的情况，把<code>k</code>从<code>1~n</code>遍历一遍相加就得到答案了。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>numTrees</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>k</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>+=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>*</span> <span class=n>dp</span><span class=p>[</span><span class=n>k</span><span class=o>-</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp</span><span class=p>.</span><span class=n>back</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>这道题比较有意思的是它的数学解法，其实就是卡特兰数（这里的递归推道出来的，没有去证明了）。</p><p>我想说的是，关于<code>n</code>个数字按顺序入栈有多少种出栈顺序，虽然知道结果是卡特兰数但一直不知道怎么来的。那么这里这种递归（动态规划）可以认为是一种做法。和这里一样，但root根就是以某个数出栈来算了(前面的是出栈顺序和后面的出栈顺序)。</p><h3 class="relative group">416. 分割等和子集<div id=416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86 aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/partition-equal-subset-sum/ target=_blank>https://leetcode.cn/problems/partition-equal-subset-sum/</a></p><p>给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。</p><p><em>题解</em></p><p>必须要先转化一下题目，首先如果可以分解为两个相等的子集，则<code>sum(nums)</code>必须可以整除2才能划分。</p><p>如果能够被整除，设<code>target = sum(nums)/2</code>，并且现在问题转化为了能否从集合中找到和为<code>target</code>的子集，这变成经典的01背包问题了。</p><p>我最初的想法如下，设<code>dp[i][t]</code>为从<code>0-i</code>集合中能否（<code>true or false</code>）找到和为<code>t</code>的子集，转移方程如下：</p><p>$$
dp[i][t] =
\begin{cases}
dp[i-1][t], t &lt; nums[i]\
dp[i-1][t- nums[i]] + nums[i], t >= nums[i] \
\end{cases}
$$</p><p>并且考虑到<code>target</code>可能很大就没有去用完整的数组，以及自下而上的方式，而是自上而下的。代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>std</span><span class=o>::</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>bool</span><span class=o>&gt;&gt;</span> <span class=n>dp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=nf>canPartition</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>nums</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>num</span> <span class=p>:</span> <span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>sum</span> <span class=o>+=</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sum</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>target</span> <span class=o>=</span> <span class=n>sum</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>dp</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>_recur</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>target</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=nf>_recur</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>nums</span><span class=p>,</span> <span class=kt>int</span> <span class=n>idx</span><span class=p>,</span> <span class=kt>int</span> <span class=n>target</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>target</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span><span class=o>&amp;</span> <span class=n>memo</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>idx</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>memo</span><span class=p>.</span><span class=n>count</span><span class=p>(</span><span class=n>target</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>target</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span><span class=p>(</span><span class=n>idx</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>      <span class=n>memo</span><span class=p>[</span><span class=n>target</span><span class=p>]</span> <span class=o>=</span> <span class=n>nums</span><span class=p>[</span><span class=n>idx</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span><span class=k>else</span>
</span></span><span class=line><span class=cl>      <span class=n>memo</span><span class=p>[</span><span class=n>target</span><span class=p>]</span> <span class=o>=</span> <span class=n>_recur</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>idx</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>target</span> <span class=o>-</span> <span class=n>nums</span><span class=p>[</span><span class=n>idx</span><span class=p>])</span> <span class=o>||</span> <span class=n>_recur</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>idx</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>target</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>target</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>过倒是能过就是慢了一点。</p><p>其实这里<code>1 &lt;= nums[i] &lt;= 100</code>，不算大还是使用常规的自下而上，再加上滚动数组优化好了。</p><p>这里稍微有点不一样，<code>dp[i][t]</code>是按照背包的思维，为此时能放的最大值，最后再来判断是否和<code>target</code>相等。</p><blockquote><p>其实用我上面的<code>bool</code>也是一样的，懒得去改了</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=kt>bool</span> <span class=n>canPartition</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>nums</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>num</span> <span class=p>:</span> <span class=n>nums</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=n>sum</span> <span class=o>+=</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>sum</span> <span class=o>%</span> <span class=mi>2</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>target</span> <span class=o>=</span> <span class=n>sum</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>target</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=n>target</span><span class=p>;</span> <span class=n>t</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=p>;</span> <span class=n>t</span><span class=o>--</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>t</span> <span class=o>&gt;=</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>t</span><span class=p>]</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>t</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>t</span><span class=o>-</span><span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]]</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>target</span><span class=p>]</span> <span class=o>==</span> <span class=n>target</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">1049. 最后一块石头的重量 II<div id=1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-ii class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8F-ii aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/last-stone-weight-ii/ target=_blank>https://leetcode.cn/problems/last-stone-weight-ii/</a></p><p>有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。</p><p>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &lt;= y。那么粉碎的可能结果如下：</p><p>如果 x == y，那么两块石头都会被完全粉碎；
如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。
最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。</p><p><em>题解</em></p><p>这道题麻烦在要对题目做个转化，说白了就是要把石头分成两堆，然后其对撞粉碎，差值最小。</p><p>分成两堆差值要最小，要么可以平分，不能平分那么一定一堆比一半大，一堆比一半小。</p><p>所以变为了背包问题，设<code>target = sum(nums) / 2</code>，从所有石头中选择出不超过<code>target</code>的最大值。</p><p>几乎和上一题分割子集合一样。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>lastStoneWeightII</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>stones</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=nl>w</span> <span class=p>:</span> <span class=n>stones</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>sum</span> <span class=o>+=</span> <span class=n>w</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>target</span> <span class=o>=</span> <span class=n>sum</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>target</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>stones</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=n>target</span><span class=p>;</span> <span class=n>t</span> <span class=o>&gt;=</span> <span class=n>stones</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>];</span> <span class=n>t</span><span class=o>--</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>t</span><span class=p>]</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>t</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>t</span> <span class=o>-</span> <span class=n>stones</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]]</span> <span class=o>+</span> <span class=n>stones</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>sum</span> <span class=o>-</span> <span class=n>dp</span><span class=p>[</span><span class=n>target</span><span class=p>]</span> <span class=o>-</span> <span class=n>dp</span><span class=p>[</span><span class=n>target</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">494. 目标和<div id=494-%E7%9B%AE%E6%A0%87%E5%92%8C class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#494-%E7%9B%AE%E6%A0%87%E5%92%8C aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/target-sum target=_blank>https://leetcode.cn/problems/target-sum</a></p><p>给你一个非负整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 &lsquo;+&rsquo; 或 &lsquo;-&rsquo; ，然后串联起所有整数，可以构造一个 表达式 ：</p><p>例如，nums = [2, 1] ，可以在 2 之前添加 &lsquo;+&rsquo; ，在 1 之前添加 &lsquo;-&rsquo; ，然后串联起来得到表达式 &ldquo;+2-1&rdquo; 。
返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p><em>题解</em></p><p>首先这题很容易想到如下的动态规划，设<code>dp[i][t]</code>为从前<code>i</code>个数（包含[0~i]）中结果为<code>t</code>的数量。</p><p>状态转移方程为：</p><p>$$
dp[i][t] = dp[i-1][t-v] + dp[i-1][t+v]
$$</p><blockquote><p>初始条件见代码，这里没有写</p></blockquote><p>由于这里不能使用滚动优化，而且自下而上的话也不好确定数组长度，所以这里自上而下。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>vector</span><span class=o>&lt;</span><span class=n>unordered_map</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>dp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>findTargetSumWays</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>nums</span><span class=p>,</span> <span class=kt>int</span> <span class=n>target</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>.</span><span class=n>resize</span><span class=p>(</span><span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>_recur</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>target</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>_recur</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>nums</span><span class=p>,</span> <span class=kt>int</span> <span class=n>index</span><span class=p>,</span> <span class=kt>int</span> <span class=n>target</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>index</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span><span class=o>&amp;</span> <span class=n>memo</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>index</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>memo</span><span class=p>.</span><span class=n>count</span><span class=p>(</span><span class=n>target</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>target</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>index</span> <span class=o>==</span> <span class=mi>0</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>memo</span><span class=p>[</span><span class=n>target</span><span class=p>]</span> <span class=o>=</span> <span class=n>nums</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>==</span> <span class=n>abs</span><span class=p>(</span><span class=n>target</span><span class=p>)</span> <span class=o>?</span> <span class=mi>1</span> <span class=o>:</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 都为0时，正负号均可
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span><span class=p>(</span><span class=n>target</span> <span class=o>==</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>nums</span><span class=p>[</span><span class=n>index</span><span class=p>]</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>memo</span><span class=p>[</span><span class=n>target</span><span class=p>]</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>memo</span><span class=p>[</span><span class=n>target</span><span class=p>]</span> <span class=o>=</span> <span class=n>_recur</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>index</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>target</span> <span class=o>-</span> <span class=n>nums</span><span class=p>[</span><span class=n>index</span><span class=p>])</span> <span class=o>+</span> <span class=n>_recur</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=n>index</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=n>target</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>index</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>target</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>需要注意初始条件，当<code>nums[0]</code>为0时，正负号均可，所以初始为2。</p><p>看了其他的题解，发现又可以转换为背包问题，其实划分为两个子集（全正的和全负的），设全正的和为x则有</p><p>$$
x - (sum - x) = target \
x = (target + sum) / 2
$$</p><p>由此可知<code>target + sum</code>一定要整除2，不然不可能。</p><p>所以现在问题变为了从其中选择和为x的子集有多少种。故设<code>dp[i][t]</code>为和为t的种数，状态转移方程为：</p><blockquote><p>这里i为0~(n-1)</p></blockquote><p>$$
dp[i][t] = dp[i-1][t] + dp[i-1][t-nums[i]]
$$</p><blockquote><p>初始化见代码</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>findTargetSumWays</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>nums</span><span class=p>,</span> <span class=kt>int</span> <span class=n>target</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=nl>num</span> <span class=p>:</span> <span class=n>nums</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>sum</span> <span class=o>+=</span> <span class=n>num</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>abs</span><span class=p>(</span><span class=n>target</span><span class=p>)</span> <span class=o>&gt;</span> <span class=n>sum</span> <span class=o>||</span> <span class=p>(</span><span class=n>target</span> <span class=o>+</span> <span class=n>sum</span><span class=p>)</span> <span class=o>%</span><span class=mi>2</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=p>(</span><span class=n>target</span> <span class=o>+</span> <span class=n>sum</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>t</span> <span class=o>=</span> <span class=n>x</span><span class=p>;</span> <span class=n>t</span> <span class=o>&gt;=</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=n>t</span><span class=o>--</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>t</span><span class=p>]</span> <span class=o>+=</span> <span class=n>dp</span><span class=p>[</span><span class=n>t</span> <span class=o>-</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>x</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>必须注意这里的初始情况，非常不好理解。这里设<code>dp[0]=1</code>其实代表的含义应该是<code>dp[-1][0] = 1</code>就是一个都没有时，为0仍然算一种。</p><p>比如如果数组为<code>[0, 1], target =1</code>，那么其实有两种<code>1</code>和<code>0, 1</code>，所以必须要算前面这种不选的情况，然后递推自动累加。</p><h3 class="relative group">474.一和零<div id=474%E4%B8%80%E5%92%8C%E9%9B%B6 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#474%E4%B8%80%E5%92%8C%E9%9B%B6 aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/ones-and-zeroes/ target=_blank>https://leetcode.cn/problems/ones-and-zeroes/</a></p><p>给你一个二进制字符串数组 strs 和两个整数 m 和 n 。</p><p>请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。</p><p>如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。</p><p><em>题解</em></p><p>这题是经典01背包问题，设<code>dp[i][m][n]</code>为题目要的最大子集长度。转移方程就不写了，直接看代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>findMaxForm</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;&amp;</span> <span class=n>strs</span><span class=p>,</span> <span class=kt>int</span> <span class=n>m</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=cp>#define DP(i, j) dp[(i)*(n+1)+(j)]
</span></span></span><span class=line><span class=cl><span class=cp></span>        <span class=kt>int</span><span class=o>*</span> <span class=n>dp</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[(</span><span class=n>m</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>*</span><span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>)];</span>
</span></span><span class=line><span class=cl>        <span class=n>memset</span><span class=p>(</span><span class=n>dp</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>int</span><span class=p>)</span><span class=o>*</span><span class=p>(</span><span class=n>m</span><span class=o>+</span><span class=mi>1</span><span class=p>)</span><span class=o>*</span><span class=p>(</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>strs</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>k</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>zeros</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>ones</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=k>auto</span> <span class=nl>c</span> <span class=p>:</span> <span class=n>strs</span><span class=p>[</span><span class=n>k</span><span class=o>-</span><span class=mi>1</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>c</span> <span class=o>==</span> <span class=sc>&#39;0&#39;</span><span class=p>)</span> <span class=n>zeros</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span> <span class=n>ones</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>m</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=n>zeros</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span> <span class=o>&gt;=</span> <span class=n>ones</span><span class=p>;</span> <span class=n>j</span><span class=o>--</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                    <span class=n>DP</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>)</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>DP</span><span class=p>(</span><span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>),</span> <span class=n>DP</span><span class=p>(</span><span class=n>i</span> <span class=o>-</span> <span class=n>zeros</span><span class=p>,</span> <span class=n>j</span> <span class=o>-</span> <span class=n>ones</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nf>DP</span><span class=p>(</span><span class=n>m</span><span class=p>,</span> <span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">[完全背包问题基础]<div id=%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%9F%BA%E7%A1%80 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E5%9F%BA%E7%A1%80 aria-label=Anchor>#</a></span></h3><p>完全背包其他和01背包都是一样的，只是现在每个物体有无限个可以拿。</p><p>设<code>dp[i][t]</code>为背包容量为t是从前i个物体中能得到的最大价值和，那么状态转移方程为：</p><p>$$
dp[i][t] = max(dp[i-1][t], dp[i][t-w[i]] + v[i])
$$</p><p>咋一看好像和01背包相同，但注意后一个为<code>dp[i][t-w[i]] + v[i]</code>而不是<code>i-1</code>。</p><p>所以从语义上来说<code>dp[i][t]</code>为要么在最终方案中<code>w[i]</code>一个都不拿，以及拿了一个后，还是从前<code>i</code>个物品(因为还可以拿<code>w[i]</code>)中拿时最大的值即<code>dp[i][t-w[i]]</code></p><blockquote><p>注意子问题向上推导时的逻辑性，拿了一个之后，如果最终结果中确实包含这么一个，<code>dp[i][t-w[i]] + v[i]</code>确实会更小。如果不包含，那么拿了一个后<code>dp[i][t-w[i]] + v[i]</code>将不会时最优质。</p></blockquote><blockquote><p>网上有什么先写出<code>dp[i][t] = max(dp[i-1][t], dp[i-1][t-w[i]] + v[i] +......+ dp[i-1][t-n*w[i]] + n*v[i])</code>
然后再去推导出这里我写的这个公式，不能说有问题吧。只是做题写递推式还要推导转道弯，确实也太麻烦了</p></blockquote><h3 class="relative group">518. 零钱兑换 II<div id=518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-ii aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/coin-change-ii target=_blank>https://leetcode.cn/problems/coin-change-ii</a></p><p>给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。</p><p>请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。</p><p>假设每一种面额的硬币有无限个。</p><p>题目数据保证结果符合 32 位带符号整数。</p><p><em>题解</em></p><p>同上，就是经典的完全背包问题。代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>change</span><span class=p>(</span><span class=kt>int</span> <span class=n>amount</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>coins</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>amount</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>coins</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>coins</span><span class=p>[</span><span class=n>i</span><span class=p>];</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>amount</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>+=</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=n>coins</span><span class=p>[</span><span class=n>i</span><span class=p>]];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>amount</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>这里需要注意的是滚动方程优化时的遍历顺序。由于递推方程<code>dp[i][t] = max(dp[i-1][t], dp[i][t-w[i]] + v[i])</code>需要用到上一次的，也需要用到这一次的。</p><p>所以这里必须从前往后遍历，这样<code>dp[t]</code>还是前一次的，但小于<code>t</code>的已经是这一次的值了。</p><h3 class="relative group">377. 组合总和 Ⅳ<div id=377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C- class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#377-%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C- aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/combination-sum-iv target=_blank>https://leetcode.cn/problems/combination-sum-iv</a></p><p>给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。</p><p>题目数据保证答案符合 32 位整数范围。</p><p>示例 1：</p><pre tabindex=0><code>输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
</code></pre><p>示例 2：</p><pre tabindex=0><code>输入：nums = [9], target = 3
输出：0
</code></pre><p><em>题解</em></p><p>注意这个题看似是完全背包问题，但要求排列数而不是组合数。所以其实和背包问题关系不大。</p><p>最开始的想法是设<code>dp[i][t]</code>为末尾是<code>nums[i-1]</code>的排列数量，那么转移方程如下：</p><p>$$
dp[i][t] = \sum_{k=0}^{n}dp[k][t-nums[i-1]] \
dp[0][0] = 1
$$</p><p><code>dp[0][0]</code>表示一个都不选时，<code>target=0</code>数量，应该为1，什么都不选应该认为是一种。</p><p>并且<code>dp[k][t-v]</code>当t刚好等于v时，也代表一种，所以<code>dp[0][0]=1</code></p><p>代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>combinationSum4</span><span class=p>(</span><span class=k>const</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>nums</span><span class=p>,</span> <span class=kt>int</span> <span class=n>target</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>target</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>][</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>target</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>j</span> <span class=o>&gt;=</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                    <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>k</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                        <span class=k>if</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]]</span> <span class=o>&lt;</span> <span class=n>INT_MAX</span> <span class=o>-</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>])</span>
</span></span><span class=line><span class=cl>                            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>+=</span> <span class=n>dp</span><span class=p>[</span><span class=n>k</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=n>nums</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]];</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>ret</span> <span class=o>+=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>target</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>此时答案就是以每种数结束的排列数之和。</p><blockquote><p>关于这里的INT_MAX的使用其实非常牵强，就是<code>dp[i][j] + dp[k][j-nums[i-1]] &lt; INT_MAX</code>，意思是下一次加法会溢出就不求了。但是没有为什么，不这样写就过不了会溢出。(官方题解就是这样写的)</p></blockquote><blockquote><p>最开始我改成long long也溢出，还以为想法有问题</p></blockquote><p>查看官方题解后发现还有改进空间，<code>dp[t]</code>可以直接设为要求的目标，即从<code>nums</code>数组中和为<code>t</code>的排列数。</p><blockquote><p>官方题解在写什么鬼东西？？？</p></blockquote><p>然后子问题其实和我的想法是一样的，本质上还是以每个数为结束时的排列数情况。</p><p>$$
dp[t] = \sum_{k=0}{n-1}dp[t-nums[k]] \
dp[0] = 1
$$</p><p>这里<code>dp[0]=1</code>就没什么实际含义了，只是<code>dp[t-nums[k]]</code>中<code>t</code>刚好等于<code>nums[k]</code>时应该算一种。</p><p>遍历顺序直接从小到大即可。</p><blockquote><p>注意这里的<code>dp[t]</code>中<code>t</code>就是target，所以就是普通的dp数组，所以这个遍历顺序没啥。
网上有些题解非要和完全背包扯上关系，说什么求排列就是交换两层for的顺序，求组合就是普通背包的顺序，简直在放屁</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>combinationSum4</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>nums</span><span class=p>,</span> <span class=kt>int</span> <span class=n>target</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>target</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>target</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>j</span> <span class=o>&gt;=</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&amp;&amp;</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]]</span> <span class=o>&lt;</span> <span class=n>INT_MAX</span> <span class=o>-</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>+=</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=n>nums</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]];</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>target</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">322. 零钱兑换<div id=322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#322-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2 aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/coin-change target=_blank>https://leetcode.cn/problems/coin-change</a></p><p>给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><em>题解</em></p><p>标准的完全背包问题，只初始值稍有不同，直接见代码:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>coinChange</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>coins</span><span class=p>,</span> <span class=kt>int</span> <span class=n>amount</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>amount</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>INT_MAX</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>coins</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>coins</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>];</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>amount</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=n>coins</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>amount</span><span class=p>]</span> <span class=o>==</span> <span class=n>INT_MAX</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>?</span> <span class=o>-</span><span class=mi>1</span> <span class=o>:</span> <span class=n>dp</span><span class=p>[</span><span class=n>amount</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>这里求最小的值，需要使用<code>INT_MAX</code>作为初始值。</p><h3 class="relative group">279.完全平方数<div id=279%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#279%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0 aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/perfect-squares target=_blank>https://leetcode.cn/problems/perfect-squares</a></p><p>给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。</p><p>完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。</p><p><em>题解</em></p><p>需要对问题做一个转换，可能构成和为n的完全平方数就是，<code>1,2,3....n^(0.5)</code>的每个数的平方，因为这些平方数才是小于n的。</p><p>所以现在和上一题完全一样了，就是在这个数组里找出和为n的最小数量。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>numSquares</span><span class=p>(</span><span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>up</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>sqrt</span><span class=p>(</span><span class=n>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>INT_MAX</span> <span class=o>-</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=n>i</span> <span class=o>&lt;=</span> <span class=n>up</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=kt>int</span> <span class=n>elem</span> <span class=o>=</span> <span class=n>i</span> <span class=o>*</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=n>elem</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>min</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>j</span> <span class=o>-</span> <span class=n>elem</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>]</span> <span class=o>==</span> <span class=n>INT_MAX</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>?</span> <span class=mi>0</span> <span class=o>:</span> <span class=n>dp</span><span class=p>[</span><span class=n>n</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">139. 单词拆分<div id=139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86 aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/word-break target=_blank>https://leetcode.cn/problems/word-break</a></p><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 s 则返回 true。</p><p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><em>题目</em></p><p>首先想到的就是回溯法或者说dfs遍历，再加一个记忆变量减枝。这题也确实可以这么做。</p><p>第二个想到的就是把给出的wordDict转换成字典树方便比较。</p><p>这里毕竟是学习动规，所以再考虑动规，<code>dp[i]</code>就是前<code>s[0-i]</code>的字符串是否可以被表示。转移方程就很简单了：</p><p>$$
dp[i] = dp[j] && s[j+1, i] in wordDict
dp[0] = true
$$</p><p>其中<code>s[j+1, i]</code>表示一个再wordDict中的单词。</p><p>自底向上填充dp即可，代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>wordBreak</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;&amp;</span> <span class=n>wordDict</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>unordered_set</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>dict</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>w</span> <span class=p>:</span> <span class=n>wordDict</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>dict</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>string</span> <span class=n>word</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=n>j</span><span class=p>,</span> <span class=n>i</span> <span class=o>-</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>dict</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>word</span><span class=p>)</span> <span class=o>!=</span> <span class=n>dict</span><span class=p>.</span><span class=n>end</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>()];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>wordBreak</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;&amp;</span> <span class=n>wordDict</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>unordered_set</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>dict</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=k>auto</span><span class=o>&amp;</span> <span class=nl>w</span> <span class=p>:</span> <span class=n>wordDict</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>dict</span><span class=p>.</span><span class=n>insert</span><span class=p>(</span><span class=n>w</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>i</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>string</span> <span class=n>word</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=n>j</span><span class=p>,</span> <span class=n>i</span> <span class=o>-</span> <span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>dict</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>word</span><span class=p>)</span> <span class=o>!=</span> <span class=n>dict</span><span class=p>.</span><span class=n>end</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>()];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>如果使用字典树，内层循环就变成固定的<code>O(n)</code>了。这里内层是<code>O(n^2)</code>，因为<code>substr()</code>还要消耗<code>O(n)</code></p><h3 class="relative group">198. 打家劫舍<div id=198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/house-robber target=_blank>https://leetcode.cn/problems/house-robber</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p><em>题解</em></p><p>过于简单，见代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rob</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>nums</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>dp</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span> <span class=o>=</span> <span class=n>nums</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>2</span><span class=p>]</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span> <span class=o>-</span> <span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>dp</span><span class=p>[</span><span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>()];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">213.打家劫舍II<div id=213%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Dii class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#213%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8Dii aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/house-robber-ii/ target=_blank>https://leetcode.cn/problems/house-robber-ii/</a></p><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p><p><em>题目</em></p><p>做这道题之前如果没有做过<a href=https://leetcode.cn/problems/house-robber/ target=_blank>
198.打家劫舍</a>，可能会感觉无从下手。尽管198非常简单。</p><p>这里由于多了一个限制条件，即头尾相邻，所以没法再用198那种子问题去求解了。</p><p>但是进一步考虑，如果最后一间被偷，那么<code>0和n-2</code>都不能被偷，但此时偷<code>1~n-3</code>就和198是同样的问题了。</p><p>同理如果最后一间不偷，那么<code>0~n-2</code>就变成198同样的问题了。</p><p>直接看代码:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>rob</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>nums</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>myrob</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>()</span><span class=o>-</span><span class=mi>2</span><span class=p>),</span> <span class=n>myrob</span><span class=p>(</span><span class=n>nums</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>()</span><span class=o>-</span><span class=mi>3</span><span class=p>)</span> <span class=o>+</span> <span class=n>nums</span><span class=p>.</span><span class=n>back</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 198
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span> <span class=nf>myrob</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>nums</span><span class=p>,</span> <span class=kt>int</span> <span class=n>start</span><span class=p>,</span> <span class=kt>int</span> <span class=n>end</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>end</span> <span class=o>&lt;</span> <span class=n>start</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>ns2</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>ns1</span> <span class=o>=</span> <span class=n>nums</span><span class=p>[</span><span class=n>start</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>start</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>end</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>ns2</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>max</span><span class=p>(</span><span class=n>ns1</span><span class=p>,</span> <span class=n>ns2</span> <span class=o>+</span> <span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=n>std</span><span class=o>::</span><span class=n>swap</span><span class=p>(</span><span class=n>ns1</span><span class=p>,</span> <span class=n>ns2</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ns1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">337.打家劫舍 III<div id=337%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iii class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#337%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-iii aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/house-robber-iii/ target=_blank>https://leetcode.cn/problems/house-robber-iii/</a></p><p>小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。</p><p>除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p><p>给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。</p><p><em>题解</em></p><p>比较简单的动态规划，子问题其实就是这里要求的问题。应用是否偷当前节点来组合子问题和值，这里不写转移方程了，直接看代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>unordered_map</span><span class=o>&lt;</span><span class=n>TreeNode</span><span class=o>*</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>memo</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>rob</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*</span> <span class=n>root</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>root</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>memo</span><span class=p>.</span><span class=n>count</span><span class=p>(</span><span class=n>root</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>root</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>not_steal</span> <span class=o>=</span> <span class=n>rob</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=n>rob</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>steal_val</span> <span class=o>=</span> <span class=n>root</span><span class=o>-&gt;</span><span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>steal_val</span> <span class=o>+=</span> <span class=n>rob</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>left</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=n>rob</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>left</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>steal_val</span> <span class=o>+=</span> <span class=n>rob</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>right</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>)</span> <span class=o>+</span> <span class=n>rob</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>right</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>memo</span><span class=p>[</span><span class=n>root</span><span class=p>]</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>not_steal</span><span class=p>,</span> <span class=n>steal_val</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>这里其实就是深度优先遍历，空间复杂度就是树高，时间复杂度也是O(n)</p><p>但这里对于<code>rob()</code>的调用太多，并且需要使用一个HashMap。可以做如下优化，即直接返回选择当前节点和不选当前节点最优值来组合：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>pair</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>_rob</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*</span> <span class=n>root</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_pair</span><span class=p>(</span><span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>root</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>l</span> <span class=o>=</span> <span class=n>_rob</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>r</span> <span class=o>=</span> <span class=n>_rob</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>ret</span><span class=p>.</span><span class=n>first</span> <span class=o>=</span> <span class=n>root</span><span class=o>-&gt;</span><span class=n>val</span> <span class=o>+</span> <span class=n>l</span><span class=p>.</span><span class=n>second</span> <span class=o>+</span> <span class=n>r</span><span class=p>.</span><span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 注意这行，求不选当前节点的最大值时，子节点不一定要选，也可以不选。
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ret</span><span class=p>.</span><span class=n>second</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>l</span><span class=p>.</span><span class=n>first</span><span class=p>,</span> <span class=n>l</span><span class=p>.</span><span class=n>second</span><span class=p>)</span> <span class=o>+</span> <span class=n>max</span><span class=p>(</span><span class=n>r</span><span class=p>.</span><span class=n>first</span><span class=p>,</span> <span class=n>r</span><span class=p>.</span><span class=n>second</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>rob</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*</span> <span class=n>root</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>_rob</span><span class=p>(</span><span class=n>root</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>max</span><span class=p>(</span><span class=n>ret</span><span class=p>.</span><span class=n>first</span><span class=p>,</span> <span class=n>ret</span><span class=p>.</span><span class=n>second</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">647. 回文子串<div id=647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#647-%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2 aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/palindromic-substrings/ target=_blank>https://leetcode.cn/problems/palindromic-substrings/</a></p><p>给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。</p><p>回文字符串 是正着读和倒过来读一样的字符串。</p><p>子字符串 是字符串中的由连续字符组成的一个序列。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p><em>题解</em></p><p>先看动规的解法，设置<code>dp[i][j]</code>表示字符串<code>s[i:j+1]</code>是否为回文子串，转移方程：</p><p>$$
dp[i][j] =
\begin{cases}
dp[i+1][j-1], s[i+1] == j[j-1] \
false, s[i-1] \neq j[j-1] \
\end{cases} \
$$</p><blockquote><p>不好找子问题的时候，去找可能存在的递归关系，然后再考虑是否能再求完改递归后，再转变为自己要求的。</p></blockquote><p>对于初始值是去了巧的，当计算时，如果<code>i+1 > j-1</code>那么自动为true。</p><p>遍历顺序，把这个二维数组画出来，可以发现求任意<code>[i][j]</code>需要左下角的<code>[i+1][j-1]</code>，所以需要一列一列的遍历。</p><p>在加上滚动数组优化，代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>countSubstrings</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span><span class=o>*</span> <span class=n>dp</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>[</span><span class=n>n</span><span class=o>+</span><span class=mi>1</span><span class=p>]{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>j</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span><span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span> <span class=o>&gt;</span> <span class=n>j</span> <span class=o>-</span> <span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                        <span class=n>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><blockquote><p>可以先写<code>s[i-1] != s[j-1]</code>，避免缩进的太厉害</p></blockquote><p>另外还有个朴素算法，直接遍历每个中心再中心扩散，这里使用"代码随想录"的代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>countSubstrings</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>result</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>result</span> <span class=o>+=</span> <span class=n>extend</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>());</span> <span class=c1>// 以i为中心
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>result</span> <span class=o>+=</span> <span class=n>extend</span><span class=p>(</span><span class=n>s</span><span class=p>,</span> <span class=n>i</span><span class=p>,</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>());</span> <span class=c1>// 以i和i+1为中心
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>extend</span><span class=p>(</span><span class=k>const</span> <span class=n>string</span><span class=o>&amp;</span> <span class=n>s</span><span class=p>,</span> <span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>,</span> <span class=kt>int</span> <span class=n>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>res</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>while</span> <span class=p>(</span><span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>n</span> <span class=o>&amp;&amp;</span> <span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>i</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>j</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>res</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>res</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">516.最长回文子序列<div id=516%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#516%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97 aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/longest-palindromic-subsequence/ target=_blank>https://leetcode.cn/problems/longest-palindromic-subsequence/</a></p><p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。</p><p>子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。</p><p><em>题解</em></p><p>设置<code>dp[i][j]</code>为字符串<code>s[i:j+1]</code>中的最大回文子序列的长度，则转移方程如下：</p><p>$$
dp[i][j] =
\begin{cases}
dp[i+1][j-1] + 2, s[i-1] == s[j-1] \
\max(dp[i+1][j], dp[i][j-1]), s[i-1] \neq s[j-1] \
\end{cases}
$$</p><p>先不说初始值和遍历顺序，这个转移方程是需要证明的，远没有那么容易。</p><p>当$s[i-1]\neqj[j-1]$时，此时<code>s[i]</code>和<code>s[j]</code>不可能同时出现在当前要求的最长回文序列中。所以用<code>max(dp[i+1][j], dp[i][j-1])</code>没有问题。</p><p>当相等时，<code>s[i]</code>和<code>s[j]</code>同时出现再加<code>dp[i+1][j-1]</code>中的最大，此时一定是最大吗？可用反正法证明。</p><p>初始值就是<code>dp[i][i]=1</code>，其他不在上三角的设为0。</p><p>取任意<code>dp[i][j]</code>可以看到其依赖<code>dp[i+1][j-1]</code>和<code>dp[i+1][j]</code>和<code>dp[i][j-1]</code>，也就是左边、下边、左下，故按列遍历，并从下到上，此时无法使用滚动数组优化。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>longestPalindromeSubseq</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>));</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>max_str</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>--</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>i</span> <span class=o>==</span> <span class=n>j</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span><span class=k>else</span> <span class=nf>if</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>==</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span> <span class=o>&gt;</span> <span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                        <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>+</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>][</span><span class=n>j</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>max_str</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>max_str</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>][</span><span class=n>j</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>max_str</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">5. 最长回文子串<div id=5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2 aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/longest-palindromic-substring target=_blank>https://leetcode.cn/problems/longest-palindromic-substring</a></p><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><em>题解</em></p><p>这其实和<code>647. 回文子串</code>是一样的，再找所有的回文子串的时候，记录最大的回文串即可。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>string</span> <span class=n>longestPalindrome</span><span class=p>(</span><span class=n>string</span> <span class=n>s</span><span class=p>){</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>s</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>n</span> <span class=o>+</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>start</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>end</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;=</span> <span class=n>n</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>j</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>s</span><span class=p>[</span><span class=n>i</span><span class=o>-</span><span class=mi>1</span><span class=p>]</span> <span class=o>!=</span> <span class=n>s</span><span class=p>[</span><span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span> <span class=o>&gt;</span> <span class=n>j</span><span class=o>-</span><span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span><span class=k>else</span><span class=p>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=o>+</span><span class=mi>1</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=mi>1</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                    <span class=k>if</span><span class=p>(</span><span class=n>j</span> <span class=o>-</span> <span class=n>i</span> <span class=o>&gt;=</span> <span class=n>end</span> <span class=o>-</span> <span class=n>start</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                        <span class=n>start</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                        <span class=n>end</span> <span class=o>=</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                    <span class=p>}</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>s</span><span class=p>.</span><span class=n>substr</span><span class=p>(</span><span class=n>start</span><span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>end</span><span class=o>-</span><span class=n>start</span><span class=o>+</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><h3 class="relative group">121. 买卖股票的最佳时机<div id=121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/ target=_blank>https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</a></p><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><p><em>题解</em></p><p>从左开始通过局部最小值计算。</p><p><figure><img class="my-0 rounded-md" src=./imgs/121-stock.png alt=example></figure></p><p>先设最左边为最小值设其下标为i，在遇到下一个更小值(设为j)之前，都比他大。</p><p>所以在i到j之间（不包括j）可以计算出此时的最大利润。(这在下文中被称为一块)</p><p>当将i更新为j后，同理又可以计算下一块局部最大利润。</p><p>但为什么，只需要比较每个块的最大利润就可以确定全局的最大利润呢？可用反证法。</p><p>设存在一个更大利润，是跨了这里的块的，设左边买入索引为<code>k</code>右边的为<code>s</code>。</p><p><figure><img class="my-0 rounded-md" src=./imgs/121-stock-example.png alt=example></figure></p><p>由上述性质可知（绿色块越来越小），可以证，总有<code>m</code>比<code>k</code>更小，从而利润更大，即块中利润始终比跨块的利润更大。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>maxProfit</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>prices</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>p</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>max_val</span> <span class=o>=</span> <span class=o>-</span><span class=mi>1</span><span class=p>,</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>prices</span><span class=p>.</span><span class=n>size</span><span class=p>();</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=n>tmp</span> <span class=o>=</span> <span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>prices</span><span class=p>[</span><span class=n>p</span><span class=p>];</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>tmp</span> <span class=o>&gt;</span> <span class=n>max_val</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=n>max_val</span> <span class=o>=</span> <span class=n>tmp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>prices</span><span class=p>[</span><span class=n>p</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                <span class=n>p</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span><span class=p>(</span><span class=n>max_val</span> <span class=o>&lt;</span> <span class=mi>0</span><span class=p>)</span> <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>max_val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>其次可以使用动态规划去理解，设<code>dp[i]</code>为前i天中的最小价格。那么可以得到，如果一定要第i天卖出时可得的最大利润。</p><p>最优结果一定时某天卖出，所以通过比较就可以得出结果。</p><p>而<code>dp[i] = min(dp[i-1], price[i])</code>，再已知<code>dp[i-1]</code>时，就多了一天，所以直接比较就可知。</p><p>可以求<code>dp[i]</code>和第i天卖出的最大值，以及比较这个值，可以在一个循环中同时进行。</p><h3 class="relative group">122. 买卖股票的最佳时机 II<div id=122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#122-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii target=_blank>https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii</a></p><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><p><em>题解</em></p><p>又是贪心，都要贪心恐惧症了，这证明也太烦人了。</p><p>做法很简单，只需要选择每个"上坡"的最低点买入，最高点卖出，然后累加起来。</p><p><figure><img class="my-0 rounded-md" src=./imgs/122-stcok1.png alt=122-stock></figure></p><p>即图中的绿色部分，这里没有考虑两天连续相等的情况（也不需要考虑）。</p><p>反证法，设现在存在一个不是这样买的方案最大，证明矛盾。</p><p>现在从该方案的最后一次买入开始考虑，其可能是两种情况：</p><p><figure><img class="my-0 rounded-md" src=./imgs/122-stock2.png alt=122-stock></figure></p><p>当然这里的第二种情况，这里只是画出了一个例子，通用例子是中间有1个或者多个"尖"，并且最左下可能是下坡，最右上也可能是上坡，这里就没有去画了，因为证明是一样的。</p><p>对于第一种，左边的下到最低，右边的上到最优，这种方案肯定比他大，但也就是我们的上坡方案。</p><p>对于第二种，同样的左边下到最低，右边上到最高的方案也比当前大（想不明白的，可以先左边下到最低时，一定比原方案大，然后再右上，一定有比该方案大）。完了以后，在这个更大方案上，如果不一次买卖，而是拆成多次上坡的买卖一定又更大，因为这些绿色的上坡之间在y轴上有重合，故一定大。</p><p>这样就证明了，这个最后一次买入，一定是小于等于拆成所有买上坡的。</p><p>但这里还有一个问题，如果左边向最小下滑时前次卖出挡住了呢？</p><p><figure><img class="my-0 rounded-md" src=./imgs/122-stock3.png alt=122-stock3></figure></p><p>此时可以同时将该前一次卖出下滑，此时整体上反而还是会变大的。最后一次下滑肯定是增大的，而且增大的比前一次减少的还要多。</p><p>好如此一来，可以将最后一次替换成多次买上坡的方案比假设的这个最大的更大，矛盾。</p><p>然后代码就没啥好说的了：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>maxProfit</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>prices</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>start</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>max_profit</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>prices</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>prices</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>prices</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>]</span> <span class=o>&lt;</span> <span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                <span class=n>max_profit</span> <span class=o>+=</span> <span class=n>prices</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>-</span> <span class=n>prices</span><span class=p>[</span><span class=n>start</span><span class=p>];</span>
</span></span><span class=line><span class=cl>                <span class=n>start</span> <span class=o>=</span> <span class=n>i</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>max_profit</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>这里取了个巧去处理<code>prices</code>最后一段是上坡的情况，<code>prices.push_back(-1)</code>保证最后一定是下降的。</p><h3 class="relative group">300. 最长递增子序列<div id=300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#300-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97 aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/longest-increasing-subsequence target=_blank>https://leetcode.cn/problems/longest-increasing-subsequence</a></p><p>给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。</p><p>子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的
子序列
。</p><p><em>题解</em></p><p>第一个解法是经典动态规划：设<code>dp[i]</code>为以<code>s[i]</code>结尾的最长严格递增子序列的长度。</p><p>转移方程为：</p><p>$$
dp[n] = max_{0&lt;=i&lt;=n-1,dp[i]>dp[n]}(dp[i]) + 1
$$</p><p>比较简单，代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>lengthOfLIS</span><span class=p>(</span><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;&amp;</span> <span class=n>nums</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>dp</span><span class=p>(</span><span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>(),</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>nums</span><span class=p>.</span><span class=n>size</span><span class=p>();</span><span class=n>i</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>            <span class=k>for</span><span class=p>(</span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=n>j</span> <span class=o>&lt;</span> <span class=n>i</span><span class=p>;</span><span class=n>j</span><span class=o>++</span><span class=p>){</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span><span class=p>(</span><span class=n>nums</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>nums</span><span class=p>[</span><span class=n>j</span><span class=p>]){</span>
</span></span><span class=line><span class=cl>                    <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>=</span> <span class=n>max</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>dp</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>                <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>&gt;</span> <span class=n>ret</span><span class=p>)</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>dp</span><span class=p>[</span><span class=n>i</span><span class=p>];</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>但其复杂度为O(n^2)</p><p>第二种解法，通过维护数组<code>d[i]</code>和<code>len</code>的合法性来找。</p><p>这本质上是一种贪心算法，<code>d[i]</code>表示长度为i的所有子序列中末尾最小的那个子序列的末尾，而且显而易见<code>d</code>数组是严格递增的。</p><p>而<code>len</code>则表示<code>d</code>数组的长度。</p><p>所以最开始<code>len = 1</code>, <code>d[1]=nums[0]</code>，这显然是合法的。</p><p>然后从<code>1</code>开始扫描<code>nums</code>数组，并不断维护<code>d</code>和<code>len</code>的合法性，最终<code>len</code>就是结果。</p><p>比如遍历到<code>i</code>时，<code>d</code>和<code>len</code>表示此时<code>0~i-1</code>中子序列的情况，此时如果<code>nums[i] > d[len]</code>则表示可以新增一个更长的子序列<code>len++, d[len]=nums[i]</code></p><p>如果<code>nums[i] &lt; d[len]</code>，那么没有更长的子序列可以新增，要表示<code>0~i</code>的情况，需要维护<code>d</code>的合理性，则二分去找<code>d</code>中第一个比<code>nums[i]</code>小的。</p><h3 class="relative group">236. 二叉树的最近公共祖先<div id=236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88 class=anchor></div><span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88 aria-label=Anchor>#</a></span></h3><p><a href=https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree target=_blank>https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree</a></p><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><em>题解</em></p><p>这是道经典题了，做法很多，这里我选择后序的深度优先遍历。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/**
</span></span></span><span class=line><span class=cl><span class=cm> * Definition for a binary tree node.
</span></span></span><span class=line><span class=cl><span class=cm> * struct TreeNode {
</span></span></span><span class=line><span class=cl><span class=cm> *     int val;
</span></span></span><span class=line><span class=cl><span class=cm> *     TreeNode *left;
</span></span></span><span class=line><span class=cl><span class=cm> *     TreeNode *right;
</span></span></span><span class=line><span class=cl><span class=cm> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
</span></span></span><span class=line><span class=cl><span class=cm> * };
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>Solution</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>TreeNode</span><span class=o>*</span> <span class=n>lowestCommonAncestor</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*</span> <span class=n>root</span><span class=p>,</span> <span class=n>TreeNode</span><span class=o>*</span> <span class=n>p</span><span class=p>,</span> <span class=n>TreeNode</span><span class=o>*</span> <span class=n>q</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=n>q</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>ret</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>TreeNode</span><span class=o>*</span> <span class=n>ret</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=nf>dfs</span><span class=p>(</span><span class=n>TreeNode</span><span class=o>*</span> <span class=n>root</span><span class=p>,</span> <span class=n>TreeNode</span><span class=o>*</span> <span class=n>p</span><span class=p>,</span> <span class=n>TreeNode</span><span class=o>*</span> <span class=n>q</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>ret</span> <span class=o>!=</span> <span class=k>nullptr</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>cnt</span> <span class=o>=</span> <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>left</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=n>q</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>cnt</span> <span class=o>+=</span> <span class=n>dfs</span><span class=p>(</span><span class=n>root</span><span class=o>-&gt;</span><span class=n>right</span><span class=p>,</span> <span class=n>p</span><span class=p>,</span> <span class=n>q</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>root</span> <span class=o>==</span> <span class=n>p</span> <span class=o>||</span> <span class=n>root</span> <span class=o>==</span> <span class=n>q</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>cnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>cnt</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span><span class=p>(</span><span class=n>ret</span> <span class=o>==</span> <span class=k>nullptr</span><span class=p>)</span> <span class=n>ret</span> <span class=o>=</span> <span class=n>root</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>cnt</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>其实用<code>cnt</code>统计有点多余，直接让<code>dfs</code>左右子树返回是否存在即可判断。</p></div></div><script>var oid="views_posts/algorithms-and-data-structures/dynamic-planning/dp-leetcode/index.md",oid_likes="likes_posts/algorithms-and-data-structures/dynamic-planning/dp-leetcode/index.md"</script><script type=text/javascript src=/js/page.min.5b1bad196a6075a1e11bae1dc95f24f67b610948a00525e347566c5a62338ea78f1c7224ab9a53873dcdb2a1a7d7d391b8a8ef45561297f68806c01315b0c4f6.js integrity="sha512-WxutGWpgdaHhG64dyV8k9nthCUigBSXjR1ZsWmIzjqePHHIkq5pThz3NsqGn19ORuKjvRVYSl/aIBsATFbDE9g=="></script></section><footer class="pt-8 max-w-prose print:hidden"><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="flex group mr-3" href=/posts/resume-notes/><span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">Resume Notes</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2024-03-02 21:06:07 +0800 +0800">2 March 2024</time>
</span></span></a></span><span><a class="flex text-right group ml-3" href=/posts/c-family/c-struct-align/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">结构体对齐与结构体大小</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2023-11-10 14:30:55 +0800 +0800">10 November 2023</time>
</span></span><span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&larr;</span></a></span></div></div></footer></article><div id=top-scroller class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label="Scroll to top" title="Scroll to top">&uarr;</a></div></main><footer id=site-footer class="py-10 print:hidden"><nav class="flex flex-row pb-4 text-base font-medium text-neutral-500 dark:text-neutral-400"><ul class="flex flex-col list-none sm:flex-row"><li class="flex mb-1 ltr:text-right rtl:text-left sm:mb-0 ltr:sm:mr-7 ltr:sm:last:mr-0 rtl:sm:ml-7 rtl:sm:last:ml-0"><a class="decoration-primary-500 hover:underline hover:decoration-2 hover:underline-offset-2 flex items-center" href=/tags/ title>Tags</a></li></ul></nav><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">&copy;
2024
xxxgggyyy</p><p class="text-xs text-neutral-500 dark:text-neutral-400">Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a></p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/js/process.min.62060bb247f4de2b6dde45903668fefb68d792f365587605177b1227c0cf43588701edaca0cb40e2c8e2789bd5ce67c1d2a215b9fb258c3496a7cd25e7cb5fdf.js integrity="sha512-YgYLskf03itt3kWQNmj++2jXkvNlWHYFF3sSJ8DPQ1iHAe2soMtA4sjieJvVzmfB0qIVufsljDSWp80l58tf3w=="></script></footer><div id=search-wrapper class="invisible fixed inset-0 flex h-screen w-screen cursor-default flex-col bg-neutral-500/50 p-4 backdrop-blur-sm dark:bg-neutral-900/50 sm:p-6 md:p-[10vh] lg:p-[12vh]" data-url=https://xxxgggyyy.github.io/ style=z-index:500><div id=search-modal class="flex flex-col w-full max-w-3xl min-h-0 mx-auto border rounded-md shadow-lg top-20 border-neutral-200 bg-neutral dark:border-neutral-700 dark:bg-neutral-800"><header class="relative z-10 flex items-center justify-between flex-none px-2"><form class="flex items-center flex-auto min-w-0"><div class="flex items-center justify-center w-8 h-8 text-neutral-400"><span class="relative block icon"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="search" class="svg-inline--fa fa-search fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M505 442.7 405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9.0 208 0S0 93.1.0 208s93.1 208 208 208c48.3.0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9.0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7.0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7.0 128 57.2 128 128 0 70.7-57.2 128-128 128z"/></svg></span></div><input type=search id=search-query class="flex flex-auto h-12 mx-1 bg-transparent appearance-none focus:outline-dotted focus:outline-2 focus:outline-transparent" placeholder=Search tabindex=0></form><button id=close-search-button class="flex items-center justify-center w-8 h-8 text-neutral-700 hover:text-primary-600 dark:text-neutral dark:hover:text-primary-400" title="Close (Esc)">
<span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></button></header><section class="flex-auto px-2 overflow-auto"><ul id=search-results></ul></section></div></div></div></body></html>